
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Executing script file `../model/design.ys' --

1. Executing Verilog-2005 frontend: sar_adc_nonideal_conv.sv
Parsing formal SystemVerilog input from `sar_adc_nonideal_conv.sv' to AST representation.
Storing AST representation for module `$abstract\comparator_latch'.
Storing AST representation for module `$abstract\digital_to_analog_converter'.
Storing AST representation for module `$abstract\sample_and_hold'.
Storing AST representation for module `$abstract\successive_approximation_register'.
Storing AST representation for module `$abstract\sar_adc'.
Storing AST representation for module `$abstract\sar_adc__N_BITS_10'.
Storing AST representation for module `$abstract\sar_tb_working'.
Storing AST representation for module `$abstract\frequency_divider'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_tb_working'.
Generating RTLIL representation for module `\sar_tb_working'.

2.2.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Parameter \DIVISION = 4

2.2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\frequency_divider'.
Parameter \DIVISION = 4
Generating RTLIL representation for module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100'.
Parameter \N_BITS = 2

2.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc__N_BITS_10'.
Parameter \N_BITS = 2
Generating RTLIL representation for module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010'.

2.2.4. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010
Parameter \N_BITS = 2

2.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc'.
Parameter \N_BITS = 2
Generating RTLIL representation for module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010'.

2.2.6. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010

2.2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\comparator_latch'.
Generating RTLIL representation for module `\comparator_latch'.

2.2.8. Executing AST frontend in derive mode using pre-parsed AST for module `\digital_to_analog_converter'.
Generating RTLIL representation for module `\digital_to_analog_converter'.
Parameter \N_BITS = 2

2.2.9. Executing AST frontend in derive mode using pre-parsed AST for module `\successive_approximation_register'.
Parameter \N_BITS = 2
Generating RTLIL representation for module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010'.

2.2.10. Executing AST frontend in derive mode using pre-parsed AST for module `\sample_and_hold'.
Generating RTLIL representation for module `\sample_and_hold'.

2.2.11. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010
Used module:             \sample_and_hold

2.2.12. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010
Used module:             \sample_and_hold
Removing unused module `$abstract\frequency_divider'.
Removing unused module `$abstract\sar_tb_working'.
Removing unused module `$abstract\sar_adc__N_BITS_10'.
Removing unused module `$abstract\sar_adc'.
Removing unused module `$abstract\successive_approximation_register'.
Removing unused module `$abstract\sample_and_hold'.
Removing unused module `$abstract\digital_to_analog_converter'.
Removing unused module `$abstract\comparator_latch'.
Removed 8 unused modules.
Module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100 directly or indirectly contains formal properties -> setting "keep" attribute.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.
Warning: Resizing cell port $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.SAR_instance.quantized_voltage from 10 bits to 2 bits.

2.3. Executing PROC pass (convert processes to netlists).

2.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

2.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 3 switch rules as full_case in process $proc$./sample_and_hold.v:26$323 in module sample_and_hold.
Marked 1 switch rules as full_case in process $proc$./successive_approximation_register.v:31$281 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Marked 2 switch rules as full_case in process $proc$./successive_approximation_register.v:22$277 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Marked 7 switch rules as full_case in process $proc$./comparator_latch.v:774$252 in module comparator_latch.
Marked 1 switch rules as full_case in process $proc$sar_adc.v:78$180 in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
Marked 1 switch rules as full_case in process $proc$sar_adc_nonideal_conv.sv:144$167 in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
Marked 1 switch rules as full_case in process $proc$sar_adc_nonideal_conv.sv:94$62 in module sar_tb_working.
Removed a total of 0 dead cases.

2.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 2 redundant assignments.
Promoted 61 assignments to connections.

2.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$163'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:122$30_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$161'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:121$29_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$159'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:116$28_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$157'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:115$27_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$155'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:114$26_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$153'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:103$25_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$151'.
  Set init value: $formal$sar_adc_nonideal_conv.sv:101$24_EN = 1'0

2.3.5. Executing PROC_ARST pass (detect async resets in processes).

2.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~30 debug messages>

2.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:26$323'.
     1/2: $0\fsm[31:0]
     2/2: $0\state_cap[9:0]
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:20$322'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:39$305'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
     1/4: $1$lookahead\quantized_voltage_register$280[1:0]$291
     2/4: $1$bitselwrite$sel$./successive_approximation_register.v:35$276[31:0]$290
     3/4: $1$bitselwrite$data$./successive_approximation_register.v:35$275[1:0]$289
     4/4: $1$bitselwrite$mask$./successive_approximation_register.v:35$274[1:0]$288
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:22$277'.
     1/1: $0\counter[1:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:774$252'.
     1/3: $0\fsm[31:0]
     2/3: $0\o[34:0]
     3/3: $0\state_cycle_counter[16:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:765$251'.
Creating decoders for process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.$proc$sar_adc.v:78$180'.
     1/1: $0\comparator_output_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:0$176'.
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:152$171'.
     1/1: $0\output_clk_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:144$167'.
     1/1: $0\counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$163'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$161'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$159'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$157'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$155'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$153'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$151'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
     1/1: $0\held_value[9:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
     1/1: $0\hit_eoc[0:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
     1/1: $0\eoc_high_counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:43$33'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:38$31'.

2.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.\quantized_voltage' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:39$305'.
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$unnamed_block$2.i' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:39$305'.
No latch inferred for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$formal$sar_adc_nonideal_conv.sv:140$165_CHECK' from process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:0$176'.
No latch inferred for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$formal$sar_adc_nonideal_conv.sv:140$165_EN' from process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:0$176'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:57$3_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:57$3_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:59$5_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:59$5_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:60$7_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:60$7_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:62$9_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:62$9_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:64$11_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:64$11_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:66$13_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:66$13_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:67$15_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:67$15_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:68$17_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:68$17_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:76$19_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:76$19_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:77$20_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:77$20_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:77$21_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:77$21_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:80$22_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:80$22_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:83$23_CHECK' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:83$23_EN' from process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.

2.3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\sample_and_hold.\state_cap' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$323'.
  created $dff cell `$procdff$436' with positive edge clock.
Creating register for signal `\sample_and_hold.\fsm' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$323'.
  created $dff cell `$procdff$437' with positive edge clock.
Creating register for signal `\sample_and_hold.\prev_sys_clk' using process `\sample_and_hold.$proc$./sample_and_hold.v:20$322'.
  created $dff cell `$procdff$438' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.\quantized_voltage_register' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
  created $dff cell `$procdff$439' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$bitselwrite$mask$./successive_approximation_register.v:35$274' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
  created $dff cell `$procdff$440' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$bitselwrite$data$./successive_approximation_register.v:35$275' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
  created $dff cell `$procdff$441' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$bitselwrite$sel$./successive_approximation_register.v:35$276' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
  created $dff cell `$procdff$442' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$lookahead\quantized_voltage_register$280' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
  created $dff cell `$procdff$443' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.\counter' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:22$277'.
  created $dff cell `$procdff$444' with positive edge clock.
Creating register for signal `\comparator_latch.\state_cycle_counter' using process `\comparator_latch.$proc$./comparator_latch.v:774$252'.
  created $dff cell `$procdff$445' with positive edge clock.
Creating register for signal `\comparator_latch.\o' using process `\comparator_latch.$proc$./comparator_latch.v:774$252'.
  created $dff cell `$procdff$446' with positive edge clock.
Creating register for signal `\comparator_latch.\fsm' using process `\comparator_latch.$proc$./comparator_latch.v:774$252'.
  created $dff cell `$procdff$447' with positive edge clock.
Creating register for signal `\comparator_latch.\prev_sys_clk' using process `\comparator_latch.$proc$./comparator_latch.v:765$251'.
  created $dff cell `$procdff$448' with positive edge clock.
Creating register for signal `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.\comparator_output_digital' using process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.$proc$sar_adc.v:78$180'.
  created $dff cell `$procdff$449' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.\output_clk_digital' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:152$171'.
  created $dff cell `$procdff$450' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.\counter' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:144$167'.
  created $dff cell `$procdff$451' with positive edge clock.
Creating register for signal `\sar_tb_working.\held_value' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
  created $dff cell `$procdff$452' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:121$29_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
  created $dff cell `$procdff$453' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:121$29_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
  created $dff cell `$procdff$454' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:122$30_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
  created $dff cell `$procdff$455' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:122$30_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
  created $dff cell `$procdff$456' with positive edge clock.
Creating register for signal `\sar_tb_working.\hit_eoc' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$457' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:114$26_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$458' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:114$26_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$459' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:115$27_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$460' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:115$27_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$461' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:116$28_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$462' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:116$28_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
  created $dff cell `$procdff$463' with positive edge clock.
Creating register for signal `\sar_tb_working.\eoc_high_counter' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
  created $dff cell `$procdff$464' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:101$24_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
  created $dff cell `$procdff$465' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:101$24_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
  created $dff cell `$procdff$466' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:103$25_CHECK' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
  created $dff cell `$procdff$467' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_nonideal_conv.sv:103$25_EN' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
  created $dff cell `$procdff$468' with positive edge clock.
Creating register for signal `\sar_tb_working.\sys_counter' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:43$33'.
  created $dff cell `$procdff$469' with positive edge clock.
Creating register for signal `\sar_tb_working.\cycles' using process `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:38$31'.
  created $dff cell `$procdff$470' with positive edge clock.

2.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 6 empty switches in `\sample_and_hold.$proc$./sample_and_hold.v:26$323'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:26$323'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:20$322'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:39$305'.
Found and cleaned up 1 empty switch in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:31$281'.
Found and cleaned up 3 empty switches in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:22$277'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$proc$./successive_approximation_register.v:22$277'.
Found and cleaned up 13 empty switches in `\comparator_latch.$proc$./comparator_latch.v:774$252'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:774$252'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:765$251'.
Found and cleaned up 2 empty switches in `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.$proc$sar_adc.v:78$180'.
Removing empty process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.$proc$sar_adc.v:78$180'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:0$176'.
Found and cleaned up 1 empty switch in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:152$171'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:152$171'.
Found and cleaned up 1 empty switch in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:144$167'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$proc$sar_adc_nonideal_conv.sv:144$167'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$163'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$161'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$159'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$157'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$155'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$153'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$151'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:0$123'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:120$98'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:113$79'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:94$62'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:73$35'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:43$33'.
Removing empty process `sar_tb_working.$proc$sar_adc_nonideal_conv.sv:38$31'.
Cleaned up 30 empty switches.

2.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
<suppressed ~3 debug messages>
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
<suppressed ~2 debug messages>
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
<suppressed ~44 debug messages>
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
<suppressed ~2 debug messages>
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
<suppressed ~1 debug messages>
Optimizing module sar_tb_working.
<suppressed ~14 debug messages>

2.4. Executing FUTURE pass.

2.5. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
Optimizing module sar_tb_working.

2.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
Finding unused cells or wires in module \sar_tb_working..
Removed 12 unused cells and 222 unused wires.
<suppressed ~23 debug messages>

2.7. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100...
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010...
Checking module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_tb_working...
Found and reported 0 problems.

2.8. Executing OPT pass (performing simple optimizations).

2.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010'.
<suppressed ~24 debug messages>
Finding identical cells in module `\comparator_latch'.
<suppressed ~27 debug messages>
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
<suppressed ~6 debug messages>
Finding identical cells in module `\sar_tb_working'.
<suppressed ~60 debug messages>
Removed a total of 40 cells.

2.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$387.
    dead port 1/2 on $mux $procmux$392.
    dead port 1/2 on $mux $procmux$396.
    dead port 1/2 on $mux $procmux$400.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$336.
    dead port 1/2 on $mux $procmux$341.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port B of cell $procmux$431: \hit_eoc -> 1'1
  Analyzing evaluation results.
Removed 6 multiplexer ports.
<suppressed ~15 debug messages>

2.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
  Optimizing cells in module \comparator_latch.
    New ctrl vector for $pmux cell $procmux$389: { $auto$opt_reduce.cc:134:opt_pmux$472 $procmux$376_CMP $procmux$370_CMP }
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
    New ctrl vector for $pmux cell $procmux$338: $procmux$331_CMP
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_tb_working.
  Optimizing cells in module \sar_tb_working.
Performed a total of 3 changes.

2.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 47 unused wires.
<suppressed ~5 debug messages>

2.8.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.8.8. Rerunning OPT passes. (Maybe there is more to do..)

2.8.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~14 debug messages>

2.8.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_tb_working.
Performed a total of 0 changes.

2.8.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..

2.8.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.8.14. Finished OPT passes. (There is nothing left to do.)

2.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$mul$sar_adc_nonideal_conv.sv:146$168 ($mul).
Removed top 29 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$ne$sar_adc_nonideal_conv.sv:146$169 ($ne).
Removed top 31 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$add$sar_adc_nonideal_conv.sv:147$170 ($add).
Removed top 29 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.$eq$sar_adc_nonideal_conv.sv:153$173 ($eq).
Removed top 24 bits (of 32) from port B of cell $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.$gt$sar_adc.v:82$182 ($gt).
Removed top 8 bits (of 10) from wire $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.output_result_digital_prescale.
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$div$./successive_approximation_register.v:35$292 ($div).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$add$./successive_approximation_register.v:26$279 ($add).
Removed top 30 bits (of 32) from port Y of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$add$./successive_approximation_register.v:26$279 ($add).
Removed top 30 bits (of 32) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$sub$./successive_approximation_register.v:35$293 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$sub$./successive_approximation_register.v:35$294 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$sub$./successive_approximation_register.v:0$295 ($sub).
Converting cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$sub$./successive_approximation_register.v:0$295 ($sub) from signed to unsigned.
Removed top 1 bits (of 33) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$sub$./successive_approximation_register.v:0$295 ($sub).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$ternary$./successive_approximation_register.v:42$312 ($mux).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$eq$./successive_approximation_register.v:42$316 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$ternary$./successive_approximation_register.v:42$318 ($mux).
Removed top 30 bits (of 32) from wire $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.$add$./successive_approximation_register.v:26$279_Y.
Removed top 1 bits (of 51) from port B of cell comparator_latch.$div$./comparator_latch.v:367$213 ($div).
Removed top 1 bits (of 59) from port B of cell comparator_latch.$div$./comparator_latch.v:702$240 ($div).
Removed top 54 bits (of 105) from port A of cell comparator_latch.$mul$./comparator_latch.v:108$187 ($mul).
Removed top 52 bits (of 101) from port A of cell comparator_latch.$mul$./comparator_latch.v:143$190 ($mul).
Removed top 33 bits (of 48) from port B of cell comparator_latch.$add$./comparator_latch.v:166$194 ($add).
Removed top 82 bits (of 146) from port B of cell comparator_latch.$mul$./comparator_latch.v:184$195 ($mul).
Removed top 67 bits (of 146) from port Y of cell comparator_latch.$mul$./comparator_latch.v:184$195 ($mul).
Removed top 49 bits (of 95) from port A of cell comparator_latch.$mul$./comparator_latch.v:260$200 ($mul).
Removed top 46 bits (of 92) from port A of cell comparator_latch.$mul$./comparator_latch.v:300$203 ($mul).
Removed top 81 bits (of 92) from port B of cell comparator_latch.$mul$./comparator_latch.v:300$203 ($mul).
Removed top 35 bits (of 92) from port Y of cell comparator_latch.$mul$./comparator_latch.v:300$203 ($mul).
Removed top 31 bits (of 43) from port B of cell comparator_latch.$add$./comparator_latch.v:315$204 ($add).
Removed top 32 bits (of 43) from port B of cell comparator_latch.$add$./comparator_latch.v:315$205 ($add).
Removed top 3 bits (of 43) from port Y of cell comparator_latch.$add$./comparator_latch.v:315$205 ($add).
Removed top 3 bits (of 43) from port A of cell comparator_latch.$add$./comparator_latch.v:315$205 ($add).
Removed top 43 bits (of 83) from port B of cell comparator_latch.$mul$./comparator_latch.v:372$214 ($mul).
Removed top 134 bits (of 152) from port A of cell comparator_latch.$mul$./comparator_latch.v:420$219 ($mul).
Removed top 54 bits (of 105) from port A of cell comparator_latch.$mul$./comparator_latch.v:468$222 ($mul).
Removed top 52 bits (of 101) from port A of cell comparator_latch.$mul$./comparator_latch.v:503$225 ($mul).
Removed top 34 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:526$229 ($add).
Removed top 81 bits (of 144) from port B of cell comparator_latch.$mul$./comparator_latch.v:544$230 ($mul).
Removed top 68 bits (of 144) from port Y of cell comparator_latch.$mul$./comparator_latch.v:544$230 ($mul).
Removed top 47 bits (of 94) from port A of cell comparator_latch.$mul$./comparator_latch.v:604$233 ($mul).
Removed top 83 bits (of 94) from port B of cell comparator_latch.$mul$./comparator_latch.v:604$233 ($mul).
Removed top 36 bits (of 94) from port Y of cell comparator_latch.$mul$./comparator_latch.v:604$233 ($mul).
Removed top 53 bits (of 103) from port A of cell comparator_latch.$mul$./comparator_latch.v:634$234 ($mul).
Removed top 32 bits (of 47) from port A of cell comparator_latch.$add$./comparator_latch.v:656$237 ($add).
Removed top 34 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:656$238 ($add).
Removed top 3 bits (of 47) from port Y of cell comparator_latch.$add$./comparator_latch.v:656$238 ($add).
Removed top 3 bits (of 47) from port A of cell comparator_latch.$add$./comparator_latch.v:656$238 ($add).
Removed top 3 bits (of 35) from port A of cell comparator_latch.$sub$./comparator_latch.v:689$239 ($sub).
Removed top 66 bits (of 129) from port B of cell comparator_latch.$mul$./comparator_latch.v:707$241 ($mul).
Removed top 135 bits (of 153) from port A of cell comparator_latch.$mul$./comparator_latch.v:752$246 ($mul).
Removed top 29 bits (of 32) from port B of cell comparator_latch.$gt$./comparator_latch.v:795$259 ($gt).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$add$./comparator_latch.v:798$260 ($add).
Removed top 15 bits (of 32) from port Y of cell comparator_latch.$add$./comparator_latch.v:798$260 ($add).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$gt$./comparator_latch.v:815$265 ($gt).
Removed top 3 bits (of 35) from port B of cell comparator_latch.$gt$./comparator_latch.v:830$269 ($gt).
Removed top 29 bits (of 32) from port B of cell comparator_latch.$procmux$370_CMP0 ($eq).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$procmux$373_CMP0 ($eq).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$procmux$376_CMP0 ($eq).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$procmux$379_CMP0 ($eq).
Removed top 3 bits (of 43) from port Y of cell comparator_latch.$add$./comparator_latch.v:315$204 ($add).
Removed top 3 bits (of 43) from port A of cell comparator_latch.$add$./comparator_latch.v:315$204 ($add).
Removed top 3 bits (of 47) from port Y of cell comparator_latch.$add$./comparator_latch.v:656$237 ($add).
Removed top 3 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:656$237 ($add).
Removed top 10 bits (of 95) from port Y of cell comparator_latch.$mul$./comparator_latch.v:260$200 ($mul).
Removed top 10 bits (of 103) from port Y of cell comparator_latch.$mul$./comparator_latch.v:634$234 ($mul).
Removed top 3 bits (of 43) from wire comparator_latch.$add$./comparator_latch.v:315$204_Y.
Removed top 3 bits (of 47) from wire comparator_latch.$add$./comparator_latch.v:656$237_Y.
Removed top 15 bits (of 32) from wire comparator_latch.$add$./comparator_latch.v:798$260_Y.
Removed top 49 bits (of 95) from wire comparator_latch.padl_101.
Removed top 31 bits (of 43) from wire comparator_latch.padl_115.
Removed top 29 bits (of 32) from wire comparator_latch.padl_16.
Removed top 43 bits (of 83) from wire comparator_latch.padl_160.
Removed top 54 bits (of 105) from wire comparator_latch.padl_207.
Removed top 52 bits (of 101) from wire comparator_latch.padl_225.
Removed top 32 bits (of 44) from wire comparator_latch.padl_266.
Removed top 53 bits (of 103) from wire comparator_latch.padl_286.
Removed top 54 bits (of 105) from wire comparator_latch.padl_29.
Removed top 94 bits (of 129) from wire comparator_latch.padl_326.
Removed top 52 bits (of 101) from wire comparator_latch.padl_47.
Removed top 1 bits (of 47) from wire comparator_latch.padl_bits_102.
Removed top 30 bits (of 42) from wire comparator_latch.padl_bits_116.
Removed top 40 bits (of 41) from wire comparator_latch.padl_bits_150.
Removed top 11 bits (of 12) from wire comparator_latch.padl_bits_152.
Removed top 15 bits (of 18) from wire comparator_latch.padl_bits_17.
Removed top 1 bits (of 52) from wire comparator_latch.padl_bits_208.
Removed top 1 bits (of 50) from wire comparator_latch.padl_bits_226.
Removed top 31 bits (of 43) from wire comparator_latch.padl_bits_267.
Removed top 1 bits (of 51) from wire comparator_latch.padl_bits_287.
Removed top 1 bits (of 52) from wire comparator_latch.padl_bits_30.
Removed top 30 bits (of 64) from wire comparator_latch.padl_bits_316.
Removed top 4 bits (of 35) from wire comparator_latch.padl_bits_318.
Removed top 1 bits (of 50) from wire comparator_latch.padl_bits_48.
Removed top 1 bits (of 47) from wire comparator_latch.padr_103.
Removed top 1 bits (of 52) from wire comparator_latch.padr_209.
Removed top 1 bits (of 50) from wire comparator_latch.padr_227.
Removed top 1 bits (of 59) from wire comparator_latch.padr_260.
Removed top 32 bits (of 47) from wire comparator_latch.padr_264.
Removed top 1 bits (of 51) from wire comparator_latch.padr_288.
Removed top 1 bits (of 52) from wire comparator_latch.padr_31.
Removed top 1 bits (of 50) from wire comparator_latch.padr_49.
Removed top 1 bits (of 51) from wire comparator_latch.padr_93.
Removed top 3 bits (of 43) from wire comparator_latch.padr_97.
Removed top 1 bits (of 51) from wire comparator_latch.tau.
Removed top 1 bits (of 59) from wire comparator_latch.tau_lh.
Removed top 30 bits (of 42) from wire comparator_latch.toSInt_imm_118.
Removed top 31 bits (of 43) from wire comparator_latch.toSInt_imm_269.
Removed top 3 bits (of 47) from wire comparator_latch.toUsInt_263.
Removed top 3 bits (of 43) from wire comparator_latch.toUsInt_96.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_10.
Removed top 29 bits (of 86) from wire comparator_latch.truncR_119.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_138.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_254.
Removed top 30 bits (of 88) from wire comparator_latch.truncR_270.
Removed top 3 bits (of 96) from wire comparator_latch.truncR_284.
Removed top 1 bits (of 33) from wire comparator_latch.truncR_307.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_87.
Removed top 3 bits (of 47) from wire comparator_latch.truncR_imm_299.
Removed top 3 bits (of 47) from wire comparator_latch.truncR_shift_298.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_11.
Removed top 35 bits (of 92) from wire comparator_latch.truncval_120.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_139.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_255.
Removed top 78 bits (of 94) from wire comparator_latch.truncval_271.
Removed top 10 bits (of 103) from wire comparator_latch.truncval_285.
Removed top 2 bits (of 34) from wire comparator_latch.truncval_308.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_88.
Removed top 34 bits (of 94) from wire comparator_latch.truncval_imm_236.
Removed top 29 bits (of 32) from wire comparator_latch.wait_time.
Removed top 29 bits (of 42) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$272 ($mul).
Removed top 21 bits (of 42) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$272 ($mul).
Removed top 8 bits (of 42) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$272 ($mul).
Removed top 27 bits (of 52) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$273 ($mul).
Removed top 48 bits (of 52) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$273 ($mul).
Removed top 24 bits (of 52) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$273 ($mul).
Removed top 27 bits (of 52) from wire digital_to_analog_converter.padl_6.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padl_bits_7.
Removed top 1 bits (of 10) from wire digital_to_analog_converter.padr_0.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padr_8.
Removed top 1 bits (of 13) from wire digital_to_analog_converter.toSInt_imm_11.
Removed top 31 bits (of 32) from port B of cell sample_and_hold.$procmux$328_CMP0 ($eq).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$div$sar_adc_nonideal_conv.sv:111$78 ($div).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_nonideal_conv.sv:39$32 ($add).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_nonideal_conv.sv:44$34 ($add).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_nonideal_conv.sv:76$47 ($lt).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$ge$sar_adc_nonideal_conv.sv:77$49 ($ge).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_nonideal_conv.sv:80$51 ($gt).
Removed top 25 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_nonideal_conv.sv:83$59 ($gt).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_nonideal_conv.sv:83$60 ($lt).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_nonideal_conv.sv:95$70 ($add).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$eq$sar_adc_nonideal_conv.sv:101$71 ($eq).
Removed top 21 bits (of 32) from port A of cell sar_tb_working.$mul$sar_adc_nonideal_conv.sv:111$77 ($mul).
Removed top 11 bits (of 32) from port Y of cell sar_tb_working.$mul$sar_adc_nonideal_conv.sv:111$77 ($mul).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_nonideal_conv.sv:114$86 ($add).
Removed top 11 bits (of 32) from port Y of cell sar_tb_working.$add$sar_adc_nonideal_conv.sv:114$86 ($add).
Removed top 11 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_nonideal_conv.sv:114$87 ($lt).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_nonideal_conv.sv:115$88 ($gt).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$sub$sar_adc_nonideal_conv.sv:115$90 ($sub).
Removed top 11 bits (of 32) from port Y of cell sar_tb_working.$sub$sar_adc_nonideal_conv.sv:115$90 ($sub).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$le$sar_adc_nonideal_conv.sv:116$93 ($le).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_nonideal_conv.sv:116$95 ($gt).
Removed top 58 bits (of 64) from port B of cell sar_tb_working.$eq$sar_adc_nonideal_conv.sv:121$103 ($eq).
Removed top 11 bits (of 32) from wire sar_tb_working.$add$sar_adc_nonideal_conv.sv:114$86_Y.
Removed top 11 bits (of 32) from wire sar_tb_working.$mul$sar_adc_nonideal_conv.sv:111$77_Y.

2.10. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 74 unused wires.
<suppressed ~5 debug messages>

2.11. Executing MEMORY_COLLECT pass (generating $mem cells).

2.12. Executing OPT pass (performing simple optimizations).

2.12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.12.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..

2.12.4. Finished fast OPT passes.

2.13. Printing statistics.

=== $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100 ===

   Number of wires:                 14
   Number of wire bits:            138
   Number of public wires:           5
   Number of public wire bits:      36
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 12
     $add                            1
     $assume                         1
     $dff                            2
     $eq                             1
     $initstate                      1
     $logic_not                      2
     $mul                            1
     $mux                            2
     $ne                             1

=== $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010 ===

   Number of wires:                 16
   Number of wire bits:             71
   Number of public wires:          13
   Number of public wire bits:      68
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $dff                            1
     $gt                             1
     $mux                            2
     $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010      1
     comparator_latch                1
     digital_to_analog_converter      1
     sample_and_hold                 1

=== $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010 ===

   Number of wires:                  7
   Number of wire bits:             25
   Number of public wires:           7
   Number of public wire bits:      25
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010      1

=== $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010 ===

   Number of wires:                 30
   Number of wire bits:            200
   Number of public wires:           8
   Number of public wire bits:      11
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 27
     $add                            1
     $and                            1
     $dff                            2
     $div                            1
     $eq                             2
     $logic_and                      1
     $logic_not                      3
     $logic_or                       1
     $mux                            6
     $ne                             1
     $neg                            1
     $not                            1
     $or                             1
     $shift                          2
     $sub                            3

=== comparator_latch ===

   Number of wires:                415
   Number of wire bits:          16740
   Number of public wires:         374
   Number of public wire bits:   15981
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 65
     $add                           11
     $and                            5
     $dff                            4
     $div                            2
     $eq                             4
     $gt                             4
     $le                             2
     $logic_not                      1
     $mul                           14
     $mux                           10
     $neg                            1
     $not                            2
     $pmux                           3
     $reduce_or                      1
     $sub                            1

=== digital_to_analog_converter ===

   Number of wires:                 36
   Number of wire bits:            696
   Number of public wires:          36
   Number of public wire bits:     696
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $mul                            2

=== sample_and_hold ===

   Number of wires:                 16
   Number of wire bits:            216
   Number of public wires:           8
   Number of public wire bits:      66
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 10
     $dff                            2
     $eq                             1
     $logic_not                      1
     $mux                            5
     $pmux                           1

=== sar_tb_working ===

   Number of wires:                 76
   Number of wire bits:            525
   Number of public wires:          13
   Number of public wire bits:     184
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 90
     $add                            4
     $and                            4
     $assert                         7
     $assume                        13
     $dff                           15
     $div                            1
     $eq                             2
     $ge                             1
     $gt                             5
     $initstate                      1
     $le                             1
     $logic_not                     12
     $logic_or                       1
     $lt                             3
     $mul                            1
     $mux                            2
     $not                            2
     $or                            11
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100      1
     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010      1
     $reduce_bool                    1
     $sub                            1

=== design hierarchy ===

   sar_tb_working                    1
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100      1
     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010      1
       $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010      1
         $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010      1
         comparator_latch            1
         digital_to_analog_converter      1
         sample_and_hold             1

   Number of wires:                610
   Number of wire bits:          18611
   Number of public wires:         464
   Number of public wire bits:   17067
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                208
     $add                           17
     $and                           10
     $assert                         7
     $assume                        14
     $dff                           26
     $div                            4
     $eq                            10
     $ge                             1
     $gt                            10
     $initstate                      2
     $le                             3
     $logic_and                      1
     $logic_not                     19
     $logic_or                       2
     $lt                             3
     $mul                           18
     $mux                           27
     $ne                             2
     $neg                            2
     $not                            5
     $or                            12
     $pmux                           4
     $reduce_bool                    1
     $reduce_or                      1
     $shift                          2
     $sub                            5

2.14. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100...
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010...
Checking module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_tb_working...
Found and reported 0 problems.

3. Executing HIERARCHY pass (managing design hierarchy).

3.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100

3.2. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000010
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000010
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000010
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100
Removed 0 unused modules.
Module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000100 directly or indirectly contains formal properties -> setting "keep" attribute.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.

4. Executing jny backend.

5. Executing RTLIL backend.
Output filename: ../model/design.il

Warnings: 1 unique messages, 1 total
End of script. Logfile hash: 7abc0f9365, CPU: user 1.22s system 0.04s, MEM: 20.87 MB peak
Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 29% 5x opt_clean (0 sec), 15% 6x opt_expr (0 sec), ...
