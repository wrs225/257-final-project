
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Executing script file `../model/design.ys' --

1. Executing Verilog-2005 frontend: sar_adc_ideal_conv.sv
Parsing formal SystemVerilog input from `sar_adc_ideal_conv.sv' to AST representation.
Storing AST representation for module `$abstract\comparator_latch'.
Storing AST representation for module `$abstract\digital_to_analog_converter'.
Storing AST representation for module `$abstract\sample_and_hold'.
Storing AST representation for module `$abstract\successive_approximation_register'.
Storing AST representation for module `$abstract\sar_adc'.
Storing AST representation for module `$abstract\sar_adc__N_BITS_10'.
Storing AST representation for module `$abstract\sar_tb_working'.
Storing AST representation for module `$abstract\frequency_divider'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_tb_working'.
Generating RTLIL representation for module `\sar_tb_working'.
Warning: wire '\eoc_high_cycle' is assigned in a block at sar_adc_ideal_conv.sv:82.10-82.29.
sar_adc_ideal_conv.sv:82: Warning: Identifier `\eoc_high_cycle' is implicitly declared.

2.2.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Parameter \DIVISION = 2

2.2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\frequency_divider'.
Parameter \DIVISION = 2
Generating RTLIL representation for module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.

2.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc__N_BITS_10'.
Generating RTLIL representation for module `\sar_adc__N_BITS_10'.

2.2.4. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     \sar_adc__N_BITS_10
Parameter \N_BITS = 10

2.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc'.
Parameter \N_BITS = 10
Generating RTLIL representation for module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.

2.2.6. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010

2.2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\comparator_latch'.
Generating RTLIL representation for module `\comparator_latch'.

2.2.8. Executing AST frontend in derive mode using pre-parsed AST for module `\digital_to_analog_converter'.
Generating RTLIL representation for module `\digital_to_analog_converter'.
Parameter \N_BITS = 10

2.2.9. Executing AST frontend in derive mode using pre-parsed AST for module `\successive_approximation_register'.
Parameter \N_BITS = 10
Generating RTLIL representation for module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.

2.2.10. Executing AST frontend in derive mode using pre-parsed AST for module `\sample_and_hold'.
Generating RTLIL representation for module `\sample_and_hold'.

2.2.11. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \sample_and_hold

2.2.12. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \sample_and_hold
Removing unused module `$abstract\frequency_divider'.
Removing unused module `$abstract\sar_tb_working'.
Removing unused module `$abstract\sar_adc__N_BITS_10'.
Removing unused module `$abstract\sar_adc'.
Removing unused module `$abstract\successive_approximation_register'.
Removing unused module `$abstract\sample_and_hold'.
Removing unused module `$abstract\digital_to_analog_converter'.
Removing unused module `$abstract\comparator_latch'.
Removed 8 unused modules.
Module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010 directly or indirectly contains formal properties -> setting "keep" attribute.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.

2.3. Executing PROC pass (convert processes to netlists).

2.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

2.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 3 switch rules as full_case in process $proc$./sample_and_hold.v:26$312 in module sample_and_hold.
Marked 1 switch rules as full_case in process $proc$./successive_approximation_register.v:31$222 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Marked 2 switch rules as full_case in process $proc$./successive_approximation_register.v:22$218 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Marked 8 switch rules as full_case in process $proc$./comparator_latch.v:791$193 in module comparator_latch.
Marked 1 switch rules as full_case in process $proc$sar_adc.v:71$119 in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$sar_adc_ideal_conv.sv:110$106 in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Marked 1 switch rules as full_case in process $proc$sar_adc_ideal_conv.sv:80$55 in module sar_tb_working.
Removed a total of 0 dead cases.

2.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 1 redundant assignment.
Promoted 52 assignments to connections.

2.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$102'.
  Set init value: $formal$sar_adc_ideal_conv.sv:89$22_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$100'.
  Set init value: $formal$sar_adc_ideal_conv.sv:87$21_EN = 1'0

2.3.5. Executing PROC_ARST pass (detect async resets in processes).

2.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~29 debug messages>

2.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:26$312'.
     1/2: $0\fsm[31:0]
     2/2: $0\state_cap[9:0]
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:20$311'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$246'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
     1/4: $1$lookahead\quantized_voltage_register$221[9:0]$232
     2/4: $1$bitselwrite$sel$./successive_approximation_register.v:35$217[31:0]$231
     3/4: $1$bitselwrite$data$./successive_approximation_register.v:35$216[9:0]$230
     4/4: $1$bitselwrite$mask$./successive_approximation_register.v:35$215[9:0]$229
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$218'.
     1/1: $0\counter[4:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:791$193'.
     1/3: $0\fsm[31:0]
     2/3: $0\o[34:0]
     3/3: $0\state_cycle_counter[16:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:782$192'.
Creating decoders for process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$119'.
     1/1: $0\comparator_output_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$115'.
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:118$110'.
     1/1: $0\output_clk_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:110$106'.
     1/1: $0\counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$102'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$100'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
     1/2: $0\eoc_high_cycle[0:0]
     2/2: $0\eoc_high_counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:37$25'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:32$23'.

2.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.\quantized_voltage' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$246'.
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$unnamed_block$2.i' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$246'.
No latch inferred for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$formal$sar_adc_ideal_conv.sv:106$104_CHECK' from process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$115'.
No latch inferred for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$formal$sar_adc_ideal_conv.sv:106$104_EN' from process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$115'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:50$3_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:50$3_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:52$5_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:52$5_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:53$7_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:53$7_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:55$9_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:55$9_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:57$11_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:57$11_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:59$13_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:59$13_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:69$15_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:69$15_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:70$16_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:70$16_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:70$17_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:70$17_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:73$18_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:73$18_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:75$19_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:75$19_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:76$20_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:76$20_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.

2.3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\sample_and_hold.\state_cap' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$312'.
  created $dff cell `$procdff$428' with positive edge clock.
Creating register for signal `\sample_and_hold.\fsm' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$312'.
  created $dff cell `$procdff$429' with positive edge clock.
Creating register for signal `\sample_and_hold.\prev_sys_clk' using process `\sample_and_hold.$proc$./sample_and_hold.v:20$311'.
  created $dff cell `$procdff$430' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.\quantized_voltage_register' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
  created $dff cell `$procdff$431' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$bitselwrite$mask$./successive_approximation_register.v:35$215' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
  created $dff cell `$procdff$432' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$bitselwrite$data$./successive_approximation_register.v:35$216' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
  created $dff cell `$procdff$433' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$bitselwrite$sel$./successive_approximation_register.v:35$217' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
  created $dff cell `$procdff$434' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$lookahead\quantized_voltage_register$221' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
  created $dff cell `$procdff$435' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.\counter' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$218'.
  created $dff cell `$procdff$436' with positive edge clock.
Creating register for signal `\comparator_latch.\state_cycle_counter' using process `\comparator_latch.$proc$./comparator_latch.v:791$193'.
  created $dff cell `$procdff$437' with positive edge clock.
Creating register for signal `\comparator_latch.\o' using process `\comparator_latch.$proc$./comparator_latch.v:791$193'.
  created $dff cell `$procdff$438' with positive edge clock.
Creating register for signal `\comparator_latch.\fsm' using process `\comparator_latch.$proc$./comparator_latch.v:791$193'.
  created $dff cell `$procdff$439' with positive edge clock.
Creating register for signal `\comparator_latch.\prev_sys_clk' using process `\comparator_latch.$proc$./comparator_latch.v:782$192'.
  created $dff cell `$procdff$440' with positive edge clock.
Creating register for signal `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.\comparator_output_digital' using process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$119'.
  created $dff cell `$procdff$441' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.\output_clk_digital' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:118$110'.
  created $dff cell `$procdff$442' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.\counter' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:110$106'.
  created $dff cell `$procdff$443' with positive edge clock.
Creating register for signal `\sar_tb_working.\eoc_high_counter' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
  created $dff cell `$procdff$444' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:87$21_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
  created $dff cell `$procdff$445' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:87$21_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
  created $dff cell `$procdff$446' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:89$22_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
  created $dff cell `$procdff$447' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:89$22_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
  created $dff cell `$procdff$448' with positive edge clock.
Creating register for signal `\sar_tb_working.\eoc_high_cycle' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
  created $dff cell `$procdff$449' with positive edge clock.
Creating register for signal `\sar_tb_working.\sys_counter' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:37$25'.
  created $dff cell `$procdff$450' with positive edge clock.
Creating register for signal `\sar_tb_working.\cycles' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:32$23'.
  created $dff cell `$procdff$451' with positive edge clock.

2.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 6 empty switches in `\sample_and_hold.$proc$./sample_and_hold.v:26$312'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:26$312'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:20$311'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$246'.
Found and cleaned up 1 empty switch in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$222'.
Found and cleaned up 3 empty switches in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$218'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$218'.
Found and cleaned up 14 empty switches in `\comparator_latch.$proc$./comparator_latch.v:791$193'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:791$193'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:782$192'.
Found and cleaned up 2 empty switches in `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$119'.
Removing empty process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$119'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$115'.
Found and cleaned up 1 empty switch in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:118$110'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:118$110'.
Found and cleaned up 1 empty switch in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:110$106'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:110$106'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$102'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$100'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$78'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:80$55'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:66$27'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:37$25'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:32$23'.
Cleaned up 29 empty switches.

2.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
<suppressed ~3 debug messages>
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
<suppressed ~2 debug messages>
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
<suppressed ~46 debug messages>
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
<suppressed ~1 debug messages>
Optimizing module sar_adc__N_BITS_10.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
<suppressed ~1 debug messages>
Optimizing module sar_tb_working.
<suppressed ~9 debug messages>

2.4. Executing FUTURE pass.

2.5. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module sar_adc__N_BITS_10.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module sar_tb_working.

2.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \sar_tb_working..
Removed 12 unused cells and 215 unused wires.
<suppressed ~34 debug messages>

2.7. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010...
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_adc__N_BITS_10...
Checking module sar_tb_working...
Found and reported 0 problems.

2.8. Executing OPT pass (performing simple optimizations).

2.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
<suppressed ~96 debug messages>
Finding identical cells in module `\comparator_latch'.
<suppressed ~30 debug messages>
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
<suppressed ~6 debug messages>
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
<suppressed ~33 debug messages>
Removed a total of 56 cells.

2.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$376.
    dead port 1/2 on $mux $procmux$381.
    dead port 1/2 on $mux $procmux$385.
    dead port 1/2 on $mux $procmux$389.
    dead port 1/2 on $mux $procmux$393.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$325.
    dead port 1/2 on $mux $procmux$330.
Running muxtree optimizer on module \sar_adc__N_BITS_10..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 7 multiplexer ports.
<suppressed ~21 debug messages>

2.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module \comparator_latch.
    New ctrl vector for $pmux cell $procmux$378: { $auto$opt_reduce.cc:134:opt_pmux$453 $procmux$365_CMP $procmux$362_CMP $procmux$359_CMP }
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
    New ctrl vector for $pmux cell $procmux$327: $procmux$320_CMP
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_adc__N_BITS_10.
  Optimizing cells in module \sar_tb_working.
Performed a total of 2 changes.

2.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 63 unused wires.
<suppressed ~5 debug messages>

2.8.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.8.8. Rerunning OPT passes. (Maybe there is more to do..)

2.8.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \sar_adc__N_BITS_10..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~21 debug messages>

2.8.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_adc__N_BITS_10.
  Optimizing cells in module \sar_tb_working.
Performed a total of 0 changes.

2.8.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..

2.8.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.8.14. Finished OPT passes. (There is nothing left to do.)

2.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$mul$sar_adc_ideal_conv.sv:112$107 ($mul).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$ne$sar_adc_ideal_conv.sv:112$108 ($ne).
Removed top 31 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$add$sar_adc_ideal_conv.sv:113$109 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$eq$sar_adc_ideal_conv.sv:119$112 ($eq).
Removed top 24 bits (of 32) from port B of cell $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$gt$sar_adc.v:75$121 ($gt).
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$div$./successive_approximation_register.v:35$233 ($div).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$add$./successive_approximation_register.v:26$220 ($add).
Removed top 27 bits (of 32) from port Y of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$add$./successive_approximation_register.v:26$220 ($add).
Removed top 28 bits (of 32) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:35$234 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:35$235 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:0$236 ($sub).
Converting cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:0$236 ($sub) from signed to unsigned.
Removed top 1 bits (of 33) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:0$236 ($sub).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$253 ($mux).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$257 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$259 ($mux).
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$263 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$265 ($mux).
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$269 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$271 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$275 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$277 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$281 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$283 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$287 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$289 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$293 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$295 ($mux).
Removed top 28 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$299 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$301 ($mux).
Removed top 28 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$305 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$307 ($mux).
Removed top 27 bits (of 32) from wire $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$add$./successive_approximation_register.v:26$220_Y.
Removed top 1 bits (of 51) from port B of cell comparator_latch.$div$./comparator_latch.v:364$152 ($div).
Removed top 1 bits (of 59) from port B of cell comparator_latch.$div$./comparator_latch.v:719$181 ($div).
Removed top 54 bits (of 105) from port A of cell comparator_latch.$mul$./comparator_latch.v:105$126 ($mul).
Removed top 52 bits (of 101) from port A of cell comparator_latch.$mul$./comparator_latch.v:140$129 ($mul).
Removed top 33 bits (of 48) from port B of cell comparator_latch.$add$./comparator_latch.v:163$133 ($add).
Removed top 82 bits (of 146) from port B of cell comparator_latch.$mul$./comparator_latch.v:181$134 ($mul).
Removed top 67 bits (of 146) from port Y of cell comparator_latch.$mul$./comparator_latch.v:181$134 ($mul).
Removed top 49 bits (of 95) from port A of cell comparator_latch.$mul$./comparator_latch.v:257$139 ($mul).
Removed top 46 bits (of 92) from port A of cell comparator_latch.$mul$./comparator_latch.v:297$142 ($mul).
Removed top 81 bits (of 92) from port B of cell comparator_latch.$mul$./comparator_latch.v:297$142 ($mul).
Removed top 35 bits (of 92) from port Y of cell comparator_latch.$mul$./comparator_latch.v:297$142 ($mul).
Removed top 31 bits (of 43) from port B of cell comparator_latch.$add$./comparator_latch.v:312$143 ($add).
Removed top 32 bits (of 43) from port B of cell comparator_latch.$add$./comparator_latch.v:312$144 ($add).
Removed top 3 bits (of 43) from port Y of cell comparator_latch.$add$./comparator_latch.v:312$144 ($add).
Removed top 3 bits (of 43) from port A of cell comparator_latch.$add$./comparator_latch.v:312$144 ($add).
Removed top 43 bits (of 83) from port B of cell comparator_latch.$mul$./comparator_latch.v:369$153 ($mul).
Removed top 134 bits (of 152) from port A of cell comparator_latch.$mul$./comparator_latch.v:417$158 ($mul).
Removed top 54 bits (of 105) from port A of cell comparator_latch.$mul$./comparator_latch.v:465$161 ($mul).
Removed top 52 bits (of 101) from port A of cell comparator_latch.$mul$./comparator_latch.v:500$164 ($mul).
Removed top 34 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:523$168 ($add).
Removed top 81 bits (of 144) from port B of cell comparator_latch.$mul$./comparator_latch.v:541$169 ($mul).
Removed top 68 bits (of 144) from port Y of cell comparator_latch.$mul$./comparator_latch.v:541$169 ($mul).
Removed top 47 bits (of 94) from port A of cell comparator_latch.$mul$./comparator_latch.v:621$174 ($mul).
Removed top 83 bits (of 94) from port B of cell comparator_latch.$mul$./comparator_latch.v:621$174 ($mul).
Removed top 36 bits (of 94) from port Y of cell comparator_latch.$mul$./comparator_latch.v:621$174 ($mul).
Removed top 53 bits (of 103) from port A of cell comparator_latch.$mul$./comparator_latch.v:651$175 ($mul).
Removed top 32 bits (of 47) from port A of cell comparator_latch.$add$./comparator_latch.v:673$178 ($add).
Removed top 34 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:673$179 ($add).
Removed top 3 bits (of 47) from port Y of cell comparator_latch.$add$./comparator_latch.v:673$179 ($add).
Removed top 3 bits (of 47) from port A of cell comparator_latch.$add$./comparator_latch.v:673$179 ($add).
Removed top 3 bits (of 35) from port A of cell comparator_latch.$sub$./comparator_latch.v:706$180 ($sub).
Removed top 66 bits (of 129) from port B of cell comparator_latch.$mul$./comparator_latch.v:724$182 ($mul).
Removed top 135 bits (of 153) from port A of cell comparator_latch.$mul$./comparator_latch.v:769$187 ($mul).
Removed top 29 bits (of 32) from port B of cell comparator_latch.$gt$./comparator_latch.v:812$200 ($gt).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$add$./comparator_latch.v:815$201 ($add).
Removed top 15 bits (of 32) from port Y of cell comparator_latch.$add$./comparator_latch.v:815$201 ($add).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$gt$./comparator_latch.v:837$206 ($gt).
Removed top 3 bits (of 35) from port B of cell comparator_latch.$gt$./comparator_latch.v:852$210 ($gt).
Removed top 29 bits (of 32) from port B of cell comparator_latch.$procmux$359_CMP0 ($eq).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$procmux$362_CMP0 ($eq).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$procmux$365_CMP0 ($eq).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$procmux$368_CMP0 ($eq).
Removed top 3 bits (of 43) from port Y of cell comparator_latch.$add$./comparator_latch.v:312$143 ($add).
Removed top 3 bits (of 43) from port A of cell comparator_latch.$add$./comparator_latch.v:312$143 ($add).
Removed top 3 bits (of 47) from port Y of cell comparator_latch.$add$./comparator_latch.v:673$178 ($add).
Removed top 3 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:673$178 ($add).
Removed top 10 bits (of 95) from port Y of cell comparator_latch.$mul$./comparator_latch.v:257$139 ($mul).
Removed top 10 bits (of 103) from port Y of cell comparator_latch.$mul$./comparator_latch.v:651$175 ($mul).
Removed top 3 bits (of 43) from wire comparator_latch.$add$./comparator_latch.v:312$143_Y.
Removed top 3 bits (of 47) from wire comparator_latch.$add$./comparator_latch.v:673$178_Y.
Removed top 15 bits (of 32) from wire comparator_latch.$add$./comparator_latch.v:815$201_Y.
Removed top 49 bits (of 95) from wire comparator_latch.padl_101.
Removed top 31 bits (of 43) from wire comparator_latch.padl_115.
Removed top 29 bits (of 32) from wire comparator_latch.padl_16.
Removed top 43 bits (of 83) from wire comparator_latch.padl_160.
Removed top 54 bits (of 105) from wire comparator_latch.padl_207.
Removed top 52 bits (of 101) from wire comparator_latch.padl_225.
Removed top 32 bits (of 44) from wire comparator_latch.padl_276.
Removed top 54 bits (of 105) from wire comparator_latch.padl_29.
Removed top 53 bits (of 103) from wire comparator_latch.padl_296.
Removed top 94 bits (of 129) from wire comparator_latch.padl_336.
Removed top 52 bits (of 101) from wire comparator_latch.padl_47.
Removed top 1 bits (of 47) from wire comparator_latch.padl_bits_102.
Removed top 30 bits (of 42) from wire comparator_latch.padl_bits_116.
Removed top 40 bits (of 41) from wire comparator_latch.padl_bits_150.
Removed top 11 bits (of 12) from wire comparator_latch.padl_bits_152.
Removed top 15 bits (of 18) from wire comparator_latch.padl_bits_17.
Removed top 1 bits (of 52) from wire comparator_latch.padl_bits_208.
Removed top 1 bits (of 50) from wire comparator_latch.padl_bits_226.
Removed top 31 bits (of 43) from wire comparator_latch.padl_bits_277.
Removed top 1 bits (of 51) from wire comparator_latch.padl_bits_297.
Removed top 1 bits (of 52) from wire comparator_latch.padl_bits_30.
Removed top 1 bits (of 50) from wire comparator_latch.padl_bits_48.
Removed top 1 bits (of 47) from wire comparator_latch.padr_103.
Removed top 1 bits (of 52) from wire comparator_latch.padr_209.
Removed top 1 bits (of 50) from wire comparator_latch.padr_227.
Removed top 1 bits (of 59) from wire comparator_latch.padr_270.
Removed top 32 bits (of 47) from wire comparator_latch.padr_274.
Removed top 1 bits (of 51) from wire comparator_latch.padr_298.
Removed top 1 bits (of 52) from wire comparator_latch.padr_31.
Removed top 1 bits (of 50) from wire comparator_latch.padr_49.
Removed top 1 bits (of 51) from wire comparator_latch.padr_93.
Removed top 3 bits (of 43) from wire comparator_latch.padr_97.
Removed top 1 bits (of 51) from wire comparator_latch.tau.
Removed top 1 bits (of 59) from wire comparator_latch.tau_lh.
Removed top 30 bits (of 42) from wire comparator_latch.toSInt_imm_118.
Removed top 31 bits (of 43) from wire comparator_latch.toSInt_imm_279.
Removed top 3 bits (of 47) from wire comparator_latch.toUsInt_273.
Removed top 3 bits (of 43) from wire comparator_latch.toUsInt_96.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_10.
Removed top 29 bits (of 86) from wire comparator_latch.truncR_119.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_138.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_264.
Removed top 30 bits (of 88) from wire comparator_latch.truncR_280.
Removed top 3 bits (of 96) from wire comparator_latch.truncR_294.
Removed top 1 bits (of 33) from wire comparator_latch.truncR_317.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_87.
Removed top 3 bits (of 47) from wire comparator_latch.truncR_imm_309.
Removed top 3 bits (of 47) from wire comparator_latch.truncR_shift_308.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_11.
Removed top 35 bits (of 92) from wire comparator_latch.truncval_120.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_139.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_265.
Removed top 78 bits (of 94) from wire comparator_latch.truncval_281.
Removed top 2 bits (of 34) from wire comparator_latch.truncval_318.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_88.
Removed top 29 bits (of 32) from wire comparator_latch.wait_time.
Removed top 29 bits (of 42) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$213 ($mul).
Removed top 21 bits (of 42) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$213 ($mul).
Removed top 8 bits (of 42) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$213 ($mul).
Removed top 27 bits (of 52) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$214 ($mul).
Removed top 48 bits (of 52) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$214 ($mul).
Removed top 24 bits (of 52) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$214 ($mul).
Removed top 27 bits (of 52) from wire digital_to_analog_converter.padl_6.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padl_bits_7.
Removed top 1 bits (of 10) from wire digital_to_analog_converter.padr_0.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padr_8.
Removed top 1 bits (of 13) from wire digital_to_analog_converter.toSInt_imm_11.
Removed top 31 bits (of 32) from port B of cell sample_and_hold.$procmux$317_CMP0 ($eq).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:33$24 ($add).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:38$26 ($add).
Removed top 27 bits (of 32) from port B of cell sar_tb_working.$eq$sar_adc_ideal_conv.sv:75$41 ($eq).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_ideal_conv.sv:69$43 ($lt).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$ge$sar_adc_ideal_conv.sv:70$45 ($ge).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_ideal_conv.sv:73$47 ($gt).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:81$63 ($add).
Removed top 27 bits (of 32) from port B of cell sar_tb_working.$eq$sar_adc_ideal_conv.sv:87$64 ($eq).

2.10. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 75 unused wires.
<suppressed ~3 debug messages>

2.11. Executing MEMORY_COLLECT pass (generating $mem cells).

2.12. Executing OPT pass (performing simple optimizations).

2.12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.12.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..

2.12.4. Finished fast OPT passes.

2.13. Printing statistics.

=== $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010 ===

   Number of wires:                 14
   Number of wire bits:            138
   Number of public wires:           5
   Number of public wire bits:      36
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 12
     $add                            1
     $assume                         1
     $dff                            2
     $eq                             1
     $initstate                      1
     $logic_not                      2
     $mul                            1
     $mux                            2
     $ne                             1

=== $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010 ===

   Number of wires:                 14
   Number of wire bits:             59
   Number of public wires:          11
   Number of public wire bits:      56
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $dff                            1
     $gt                             1
     $mux                            2
     $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010      1
     comparator_latch                1
     digital_to_analog_converter      1
     sample_and_hold                 1

=== $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010 ===

   Number of wires:                 38
   Number of wire bits:            287
   Number of public wires:           8
   Number of public wire bits:      30
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 43
     $add                            1
     $and                            1
     $dff                            2
     $div                            1
     $eq                            10
     $logic_and                      1
     $logic_not                      3
     $logic_or                       1
     $mux                           14
     $ne                             1
     $neg                            1
     $not                            1
     $or                             1
     $shift                          2
     $sub                            3

=== comparator_latch ===

   Number of wires:                425
   Number of wire bits:          17051
   Number of public wires:         384
   Number of public wire bits:   16292
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 65
     $add                           11
     $and                            5
     $dff                            4
     $div                            2
     $eq                             4
     $gt                             4
     $le                             2
     $logic_not                      1
     $mul                           14
     $mux                           10
     $neg                            1
     $not                            2
     $pmux                           3
     $reduce_or                      1
     $sub                            1

=== digital_to_analog_converter ===

   Number of wires:                 36
   Number of wire bits:            696
   Number of public wires:          36
   Number of public wire bits:     696
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $mul                            2

=== sample_and_hold ===

   Number of wires:                 16
   Number of wire bits:            216
   Number of public wires:           8
   Number of public wire bits:      66
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 10
     $dff                            2
     $eq                             1
     $logic_not                      1
     $mux                            5
     $pmux                           1

=== sar_adc__N_BITS_10 ===

   Number of wires:                  7
   Number of wire bits:             25
   Number of public wires:           7
   Number of public wire bits:      25
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010      1

=== sar_tb_working ===

   Number of wires:                 43
   Number of wire bits:            342
   Number of public wires:          10
   Number of public wire bits:     153
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 52
     $add                            3
     $and                            1
     $assert                         2
     $assume                        10
     $dff                            6
     $eq                             2
     $ge                             1
     $gt                             1
     $initstate                      1
     $live                           2
     $logic_not                      8
     $logic_or                       1
     $lt                             1
     $mux                            1
     $not                            1
     $or                             8
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010      1
     $reduce_bool                    1
     sar_adc__N_BITS_10              1

=== design hierarchy ===

   sar_tb_working                    1
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010      1
     sar_adc__N_BITS_10              1
       $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010      1
         $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010      1
         comparator_latch            1
         digital_to_analog_converter      1
         sample_and_hold             1

   Number of wires:                593
   Number of wire bits:          18814
   Number of public wires:         469
   Number of public wire bits:   17354
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                186
     $add                           16
     $and                            7
     $assert                         2
     $assume                        11
     $dff                           17
     $div                            3
     $eq                            18
     $ge                             1
     $gt                             6
     $initstate                      2
     $le                             2
     $live                           2
     $logic_and                      1
     $logic_not                     15
     $logic_or                       2
     $lt                             1
     $mul                           17
     $mux                           34
     $ne                             2
     $neg                            2
     $not                            4
     $or                             9
     $pmux                           4
     $reduce_bool                    1
     $reduce_or                      1
     $shift                          2
     $sub                            4

2.14. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010...
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_adc__N_BITS_10...
Checking module sar_tb_working...
Found and reported 0 problems.

3. Executing HIERARCHY pass (managing design hierarchy).

3.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010

3.2. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Removed 0 unused modules.
Module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010 directly or indirectly contains formal properties -> setting "keep" attribute.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.

4. Executing jny backend.

5. Executing RTLIL backend.
Output filename: ../model/design.il

Warnings: 2 unique messages, 2 total
End of script. Logfile hash: 35b2722aa1, CPU: user 0.30s system 0.02s, MEM: 21.79 MB peak
Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 33% 5x opt_clean (0 sec), 15% 2x check (0 sec), ...
