
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Executing script file `../model/design.ys' --

1. Executing Verilog-2005 frontend: sar_adc_ideal_conv.sv
Parsing formal SystemVerilog input from `sar_adc_ideal_conv.sv' to AST representation.
Storing AST representation for module `$abstract\comparator_latch'.
Storing AST representation for module `$abstract\digital_to_analog_converter'.
Storing AST representation for module `$abstract\sample_and_hold'.
Storing AST representation for module `$abstract\successive_approximation_register'.
Storing AST representation for module `$abstract\sar_adc'.
Storing AST representation for module `$abstract\sar_adc__N_BITS_10'.
Storing AST representation for module `$abstract\sar_tb_working'.
Storing AST representation for module `$abstract\frequency_divider'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_tb_working'.
Generating RTLIL representation for module `\sar_tb_working'.
sar_adc_ideal_conv.sv:62: Warning: Identifier `$time' is implicitly declared.

2.2.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Parameter \DIVISION = 1000

2.2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\frequency_divider'.
Parameter \DIVISION = 1000
Generating RTLIL representation for module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000'.
sar_adc_ideal_conv.sv:87: Warning: Identifier `\sys_clk' is implicitly declared.

2.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc__N_BITS_10'.
Generating RTLIL representation for module `\sar_adc__N_BITS_10'.

2.2.4. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000
Used module:     \sar_adc__N_BITS_10
Parameter \N_BITS = 10

2.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc'.
Parameter \N_BITS = 10
Generating RTLIL representation for module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.

2.2.6. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010

2.2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\comparator_latch'.
Generating RTLIL representation for module `\comparator_latch'.

2.2.8. Executing AST frontend in derive mode using pre-parsed AST for module `\digital_to_analog_converter'.
Generating RTLIL representation for module `\digital_to_analog_converter'.
Parameter \N_BITS = 10

2.2.9. Executing AST frontend in derive mode using pre-parsed AST for module `\successive_approximation_register'.
Parameter \N_BITS = 10
Generating RTLIL representation for module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.

2.2.10. Executing AST frontend in derive mode using pre-parsed AST for module `\sample_and_hold'.
Generating RTLIL representation for module `\sample_and_hold'.

2.2.11. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \sample_and_hold

2.2.12. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \sample_and_hold
Removing unused module `$abstract\frequency_divider'.
Removing unused module `$abstract\sar_tb_working'.
Removing unused module `$abstract\sar_adc__N_BITS_10'.
Removing unused module `$abstract\sar_adc'.
Removing unused module `$abstract\successive_approximation_register'.
Removing unused module `$abstract\sample_and_hold'.
Removing unused module `$abstract\digital_to_analog_converter'.
Removing unused module `$abstract\comparator_latch'.
Removed 8 unused modules.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.
Warning: Resizing cell port sar_tb_working.fdiv.sys_counter from 32 bits to 1 bits.
Warning: Resizing cell port sar_tb_working.adc_instance.output_result_digital from 1 bits to 10 bits.
Warning: Resizing cell port sar_tb_working.adc_instance.input_voltage_real from 1 bits to 10 bits.

2.3. Executing PROC pass (convert processes to netlists).

2.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

2.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 3 switch rules as full_case in process $proc$./sample_and_hold.v:26$289 in module sample_and_hold.
Marked 1 switch rules as full_case in process $proc$./successive_approximation_register.v:31$200 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Marked 2 switch rules as full_case in process $proc$./successive_approximation_register.v:22$196 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Marked 8 switch rules as full_case in process $proc$./comparator_latch.v:791$171 in module comparator_latch.
Marked 1 switch rules as full_case in process $proc$sar_adc.v:71$97 in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$sar_adc_ideal_conv.sv:96$94 in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Marked 2 switch rules as full_case in process $proc$sar_adc_ideal_conv.sv:89$91 in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Removed a total of 0 dead cases.

2.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 1 redundant assignment.
Promoted 46 assignments to connections.

2.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$89'.
  Set init value: $formal$sar_adc_ideal_conv.sv:68$15_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$87'.
  Set init value: $formal$sar_adc_ideal_conv.sv:65$14_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$85'.
  Set init value: $formal$sar_adc_ideal_conv.sv:63$13_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$83'.
  Set init value: $formal$sar_adc_ideal_conv.sv:62$12_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$81'.
  Set init value: $formal$sar_adc_ideal_conv.sv:60$11_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$79'.
  Set init value: $formal$sar_adc_ideal_conv.sv:59$10_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$77'.
  Set init value: $formal$sar_adc_ideal_conv.sv:57$9_EN = 1'0

2.3.5. Executing PROC_ARST pass (detect async resets in processes).

2.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~30 debug messages>

2.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:26$289'.
     1/2: $0\fsm[31:0]
     2/2: $0\state_cap[9:0]
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:20$288'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$224'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
     1/4: $1$lookahead\quantized_voltage_register$199[9:0]$210
     2/4: $1$bitselwrite$sel$./successive_approximation_register.v:35$195[31:0]$209
     3/4: $1$bitselwrite$data$./successive_approximation_register.v:35$194[9:0]$208
     4/4: $1$bitselwrite$mask$./successive_approximation_register.v:35$193[9:0]$207
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$196'.
     1/1: $0\counter[4:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:791$171'.
     1/3: $0\fsm[31:0]
     2/3: $0\o[34:0]
     3/3: $0\state_cycle_counter[16:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:782$170'.
Creating decoders for process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$97'.
     1/1: $0\comparator_output_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:96$94'.
     1/1: $0\output_clk_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:89$91'.
     1/1: $0\counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$89'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$87'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$85'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$83'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$81'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$79'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$77'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:32$16'.

2.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.\quantized_voltage' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$224'.
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$unnamed_block$2.i' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$224'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:46$3_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:46$3_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:48$5_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:48$5_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:49$7_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:49$7_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.

2.3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\sample_and_hold.\state_cap' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$289'.
  created $dff cell `$procdff$406' with positive edge clock.
Creating register for signal `\sample_and_hold.\fsm' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$289'.
  created $dff cell `$procdff$407' with positive edge clock.
Creating register for signal `\sample_and_hold.\prev_sys_clk' using process `\sample_and_hold.$proc$./sample_and_hold.v:20$288'.
  created $dff cell `$procdff$408' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.\quantized_voltage_register' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
  created $dff cell `$procdff$409' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$bitselwrite$mask$./successive_approximation_register.v:35$193' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
  created $dff cell `$procdff$410' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$bitselwrite$data$./successive_approximation_register.v:35$194' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
  created $dff cell `$procdff$411' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$bitselwrite$sel$./successive_approximation_register.v:35$195' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
  created $dff cell `$procdff$412' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$lookahead\quantized_voltage_register$199' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
  created $dff cell `$procdff$413' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.\counter' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$196'.
  created $dff cell `$procdff$414' with positive edge clock.
Creating register for signal `\comparator_latch.\state_cycle_counter' using process `\comparator_latch.$proc$./comparator_latch.v:791$171'.
  created $dff cell `$procdff$415' with positive edge clock.
Creating register for signal `\comparator_latch.\o' using process `\comparator_latch.$proc$./comparator_latch.v:791$171'.
  created $dff cell `$procdff$416' with positive edge clock.
Creating register for signal `\comparator_latch.\fsm' using process `\comparator_latch.$proc$./comparator_latch.v:791$171'.
  created $dff cell `$procdff$417' with positive edge clock.
Creating register for signal `\comparator_latch.\prev_sys_clk' using process `\comparator_latch.$proc$./comparator_latch.v:782$170'.
  created $dff cell `$procdff$418' with positive edge clock.
Creating register for signal `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.\comparator_output_digital' using process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$97'.
  created $dff cell `$procdff$419' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.\output_clk_digital' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:96$94'.
  created $dff cell `$procdff$420' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.\counter' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:89$91'.
  created $dff cell `$procdff$421' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:57$9_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$422' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:57$9_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$423' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:59$10_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$424' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:59$10_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$425' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:60$11_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$426' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:60$11_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$427' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:62$12_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$428' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:62$12_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$429' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:63$13_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$430' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:63$13_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$431' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:65$14_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$432' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:65$14_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$433' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:68$15_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$434' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:68$15_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
  created $dff cell `$procdff$435' with positive edge clock.
Creating register for signal `\sar_tb_working.\cycles' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:32$16'.
  created $dff cell `$procdff$436' with positive edge clock.

2.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 6 empty switches in `\sample_and_hold.$proc$./sample_and_hold.v:26$289'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:26$289'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:20$288'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:39$224'.
Found and cleaned up 1 empty switch in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:31$200'.
Found and cleaned up 3 empty switches in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$196'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$proc$./successive_approximation_register.v:22$196'.
Found and cleaned up 14 empty switches in `\comparator_latch.$proc$./comparator_latch.v:791$171'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:791$171'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:782$170'.
Found and cleaned up 2 empty switches in `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$97'.
Removing empty process `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$proc$sar_adc.v:71$97'.
Found and cleaned up 2 empty switches in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:96$94'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:96$94'.
Found and cleaned up 2 empty switches in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:89$91'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$proc$sar_adc_ideal_conv.sv:89$91'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$89'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$87'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$85'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$83'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$81'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$79'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$77'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$64'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:57$18'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:32$16'.
Cleaned up 30 empty switches.

2.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
<suppressed ~3 debug messages>
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
<suppressed ~2 debug messages>
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
<suppressed ~46 debug messages>
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
<suppressed ~1 debug messages>
Optimizing module sar_adc__N_BITS_10.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Optimizing module sar_tb_working.
<suppressed ~10 debug messages>

2.4. Executing FUTURE pass.

2.5. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module sar_adc__N_BITS_10.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Optimizing module sar_tb_working.

2.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
Finding unused cells or wires in module \sar_tb_working..
Removed 10 unused cells and 184 unused wires.
<suppressed ~29 debug messages>

2.7. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000...
Warning: Wire $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.\sys_counter is used but has no driver.
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_adc__N_BITS_10...
Checking module sar_tb_working...
Warning: Wire sar_tb_working.$ne$sar_adc_ideal_conv.sv:63$41_Y is used but has no driver.
Found and reported 2 problems.

2.8. Executing OPT pass (performing simple optimizations).

2.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.
<suppressed ~2 debug messages>

2.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
<suppressed ~99 debug messages>
Finding identical cells in module `\comparator_latch'.
<suppressed ~30 debug messages>
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
<suppressed ~6 debug messages>
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
<suppressed ~39 debug messages>
Removed a total of 58 cells.

2.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$354.
    dead port 1/2 on $mux $procmux$359.
    dead port 1/2 on $mux $procmux$363.
    dead port 1/2 on $mux $procmux$367.
    dead port 1/2 on $mux $procmux$371.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$303.
    dead port 1/2 on $mux $procmux$308.
Running muxtree optimizer on module \sar_adc__N_BITS_10..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 7 multiplexer ports.
<suppressed ~20 debug messages>

2.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module \comparator_latch.
    New ctrl vector for $pmux cell $procmux$356: { $auto$opt_reduce.cc:134:opt_pmux$438 $procmux$343_CMP $procmux$340_CMP $procmux$337_CMP }
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
    New ctrl vector for $pmux cell $procmux$305: $procmux$298_CMP
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_adc__N_BITS_10.
  Optimizing cells in module \sar_tb_working.
Performed a total of 2 changes.

2.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 67 unused wires.
<suppressed ~4 debug messages>

2.8.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.8.8. Rerunning OPT passes. (Maybe there is more to do..)

2.8.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \sar_adc__N_BITS_10..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~20 debug messages>

2.8.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_adc__N_BITS_10.
  Optimizing cells in module \sar_tb_working.
Performed a total of 0 changes.

2.8.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..

2.8.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.8.14. Finished OPT passes. (There is nothing left to do.)

2.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 22 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$ne$sar_adc_ideal_conv.sv:91$92 ($ne).
Removed top 31 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$add$sar_adc_ideal_conv.sv:91$93 ($add).
Removed top 22 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.$eq$sar_adc_ideal_conv.sv:98$95 ($eq).
Removed top 24 bits (of 32) from port B of cell $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.$gt$sar_adc.v:75$99 ($gt).
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$div$./successive_approximation_register.v:35$211 ($div).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$add$./successive_approximation_register.v:26$198 ($add).
Removed top 27 bits (of 32) from port Y of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$add$./successive_approximation_register.v:26$198 ($add).
Removed top 28 bits (of 32) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:35$212 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:35$213 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:0$214 ($sub).
Converting cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:0$214 ($sub) from signed to unsigned.
Removed top 1 bits (of 33) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$sub$./successive_approximation_register.v:0$214 ($sub).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$231 ($mux).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$235 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$237 ($mux).
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$241 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$243 ($mux).
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$247 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$249 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$253 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$255 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$259 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$261 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$265 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$267 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$271 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$273 ($mux).
Removed top 28 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$277 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$279 ($mux).
Removed top 28 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:42$283 ($eq).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$ternary$./successive_approximation_register.v:42$285 ($mux).
Removed top 28 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$eq$./successive_approximation_register.v:46$287 ($eq).
Removed top 27 bits (of 32) from wire $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.$add$./successive_approximation_register.v:26$198_Y.
Removed top 1 bits (of 51) from port B of cell comparator_latch.$div$./comparator_latch.v:364$130 ($div).
Removed top 1 bits (of 59) from port B of cell comparator_latch.$div$./comparator_latch.v:719$159 ($div).
Removed top 54 bits (of 105) from port A of cell comparator_latch.$mul$./comparator_latch.v:105$104 ($mul).
Removed top 52 bits (of 101) from port A of cell comparator_latch.$mul$./comparator_latch.v:140$107 ($mul).
Removed top 33 bits (of 48) from port B of cell comparator_latch.$add$./comparator_latch.v:163$111 ($add).
Removed top 82 bits (of 146) from port B of cell comparator_latch.$mul$./comparator_latch.v:181$112 ($mul).
Removed top 67 bits (of 146) from port Y of cell comparator_latch.$mul$./comparator_latch.v:181$112 ($mul).
Removed top 49 bits (of 95) from port A of cell comparator_latch.$mul$./comparator_latch.v:257$117 ($mul).
Removed top 46 bits (of 92) from port A of cell comparator_latch.$mul$./comparator_latch.v:297$120 ($mul).
Removed top 81 bits (of 92) from port B of cell comparator_latch.$mul$./comparator_latch.v:297$120 ($mul).
Removed top 35 bits (of 92) from port Y of cell comparator_latch.$mul$./comparator_latch.v:297$120 ($mul).
Removed top 31 bits (of 43) from port B of cell comparator_latch.$add$./comparator_latch.v:312$121 ($add).
Removed top 32 bits (of 43) from port B of cell comparator_latch.$add$./comparator_latch.v:312$122 ($add).
Removed top 3 bits (of 43) from port Y of cell comparator_latch.$add$./comparator_latch.v:312$122 ($add).
Removed top 3 bits (of 43) from port A of cell comparator_latch.$add$./comparator_latch.v:312$122 ($add).
Removed top 43 bits (of 83) from port B of cell comparator_latch.$mul$./comparator_latch.v:369$131 ($mul).
Removed top 134 bits (of 152) from port A of cell comparator_latch.$mul$./comparator_latch.v:417$136 ($mul).
Removed top 54 bits (of 105) from port A of cell comparator_latch.$mul$./comparator_latch.v:465$139 ($mul).
Removed top 52 bits (of 101) from port A of cell comparator_latch.$mul$./comparator_latch.v:500$142 ($mul).
Removed top 34 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:523$146 ($add).
Removed top 81 bits (of 144) from port B of cell comparator_latch.$mul$./comparator_latch.v:541$147 ($mul).
Removed top 68 bits (of 144) from port Y of cell comparator_latch.$mul$./comparator_latch.v:541$147 ($mul).
Removed top 47 bits (of 94) from port A of cell comparator_latch.$mul$./comparator_latch.v:621$152 ($mul).
Removed top 83 bits (of 94) from port B of cell comparator_latch.$mul$./comparator_latch.v:621$152 ($mul).
Removed top 36 bits (of 94) from port Y of cell comparator_latch.$mul$./comparator_latch.v:621$152 ($mul).
Removed top 53 bits (of 103) from port A of cell comparator_latch.$mul$./comparator_latch.v:651$153 ($mul).
Removed top 32 bits (of 47) from port A of cell comparator_latch.$add$./comparator_latch.v:673$156 ($add).
Removed top 34 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:673$157 ($add).
Removed top 3 bits (of 47) from port Y of cell comparator_latch.$add$./comparator_latch.v:673$157 ($add).
Removed top 3 bits (of 47) from port A of cell comparator_latch.$add$./comparator_latch.v:673$157 ($add).
Removed top 3 bits (of 35) from port A of cell comparator_latch.$sub$./comparator_latch.v:706$158 ($sub).
Removed top 66 bits (of 129) from port B of cell comparator_latch.$mul$./comparator_latch.v:724$160 ($mul).
Removed top 135 bits (of 153) from port A of cell comparator_latch.$mul$./comparator_latch.v:769$165 ($mul).
Removed top 29 bits (of 32) from port B of cell comparator_latch.$gt$./comparator_latch.v:812$178 ($gt).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$add$./comparator_latch.v:815$179 ($add).
Removed top 15 bits (of 32) from port Y of cell comparator_latch.$add$./comparator_latch.v:815$179 ($add).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$gt$./comparator_latch.v:837$184 ($gt).
Removed top 3 bits (of 35) from port B of cell comparator_latch.$gt$./comparator_latch.v:852$188 ($gt).
Removed top 29 bits (of 32) from port B of cell comparator_latch.$procmux$337_CMP0 ($eq).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$procmux$340_CMP0 ($eq).
Removed top 30 bits (of 32) from port B of cell comparator_latch.$procmux$343_CMP0 ($eq).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$procmux$346_CMP0 ($eq).
Removed top 3 bits (of 43) from port Y of cell comparator_latch.$add$./comparator_latch.v:312$121 ($add).
Removed top 3 bits (of 43) from port A of cell comparator_latch.$add$./comparator_latch.v:312$121 ($add).
Removed top 3 bits (of 47) from port Y of cell comparator_latch.$add$./comparator_latch.v:673$156 ($add).
Removed top 3 bits (of 47) from port B of cell comparator_latch.$add$./comparator_latch.v:673$156 ($add).
Removed top 10 bits (of 95) from port Y of cell comparator_latch.$mul$./comparator_latch.v:257$117 ($mul).
Removed top 10 bits (of 103) from port Y of cell comparator_latch.$mul$./comparator_latch.v:651$153 ($mul).
Removed top 3 bits (of 43) from wire comparator_latch.$add$./comparator_latch.v:312$121_Y.
Removed top 3 bits (of 47) from wire comparator_latch.$add$./comparator_latch.v:673$156_Y.
Removed top 15 bits (of 32) from wire comparator_latch.$add$./comparator_latch.v:815$179_Y.
Removed top 49 bits (of 95) from wire comparator_latch.padl_101.
Removed top 31 bits (of 43) from wire comparator_latch.padl_115.
Removed top 29 bits (of 32) from wire comparator_latch.padl_16.
Removed top 43 bits (of 83) from wire comparator_latch.padl_160.
Removed top 54 bits (of 105) from wire comparator_latch.padl_207.
Removed top 52 bits (of 101) from wire comparator_latch.padl_225.
Removed top 32 bits (of 44) from wire comparator_latch.padl_276.
Removed top 54 bits (of 105) from wire comparator_latch.padl_29.
Removed top 53 bits (of 103) from wire comparator_latch.padl_296.
Removed top 94 bits (of 129) from wire comparator_latch.padl_336.
Removed top 52 bits (of 101) from wire comparator_latch.padl_47.
Removed top 1 bits (of 47) from wire comparator_latch.padl_bits_102.
Removed top 30 bits (of 42) from wire comparator_latch.padl_bits_116.
Removed top 40 bits (of 41) from wire comparator_latch.padl_bits_150.
Removed top 11 bits (of 12) from wire comparator_latch.padl_bits_152.
Removed top 15 bits (of 18) from wire comparator_latch.padl_bits_17.
Removed top 1 bits (of 52) from wire comparator_latch.padl_bits_208.
Removed top 1 bits (of 50) from wire comparator_latch.padl_bits_226.
Removed top 31 bits (of 43) from wire comparator_latch.padl_bits_277.
Removed top 1 bits (of 51) from wire comparator_latch.padl_bits_297.
Removed top 1 bits (of 52) from wire comparator_latch.padl_bits_30.
Removed top 30 bits (of 64) from wire comparator_latch.padl_bits_326.
Removed top 4 bits (of 35) from wire comparator_latch.padl_bits_328.
Removed top 1 bits (of 50) from wire comparator_latch.padl_bits_48.
Removed top 1 bits (of 47) from wire comparator_latch.padr_103.
Removed top 1 bits (of 52) from wire comparator_latch.padr_209.
Removed top 1 bits (of 50) from wire comparator_latch.padr_227.
Removed top 1 bits (of 59) from wire comparator_latch.padr_270.
Removed top 32 bits (of 47) from wire comparator_latch.padr_274.
Removed top 1 bits (of 51) from wire comparator_latch.padr_298.
Removed top 1 bits (of 52) from wire comparator_latch.padr_31.
Removed top 1 bits (of 50) from wire comparator_latch.padr_49.
Removed top 1 bits (of 51) from wire comparator_latch.padr_93.
Removed top 3 bits (of 43) from wire comparator_latch.padr_97.
Removed top 1 bits (of 51) from wire comparator_latch.tau.
Removed top 1 bits (of 59) from wire comparator_latch.tau_lh.
Removed top 30 bits (of 42) from wire comparator_latch.toSInt_imm_118.
Removed top 31 bits (of 43) from wire comparator_latch.toSInt_imm_279.
Removed top 3 bits (of 47) from wire comparator_latch.toUsInt_273.
Removed top 3 bits (of 43) from wire comparator_latch.toUsInt_96.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_10.
Removed top 29 bits (of 86) from wire comparator_latch.truncR_119.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_138.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_264.
Removed top 30 bits (of 88) from wire comparator_latch.truncR_280.
Removed top 3 bits (of 96) from wire comparator_latch.truncR_294.
Removed top 1 bits (of 33) from wire comparator_latch.truncR_317.
Removed top 1 bits (of 13) from wire comparator_latch.truncR_87.
Removed top 3 bits (of 47) from wire comparator_latch.truncR_imm_309.
Removed top 3 bits (of 47) from wire comparator_latch.truncR_shift_308.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_11.
Removed top 35 bits (of 92) from wire comparator_latch.truncval_120.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_139.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_265.
Removed top 78 bits (of 94) from wire comparator_latch.truncval_281.
Removed top 2 bits (of 34) from wire comparator_latch.truncval_318.
Removed top 2 bits (of 14) from wire comparator_latch.truncval_88.
Removed top 29 bits (of 32) from wire comparator_latch.wait_time.
Removed top 29 bits (of 42) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$191 ($mul).
Removed top 21 bits (of 42) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$191 ($mul).
Removed top 8 bits (of 42) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$191 ($mul).
Removed top 27 bits (of 52) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$192 ($mul).
Removed top 48 bits (of 52) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$192 ($mul).
Removed top 24 bits (of 52) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$192 ($mul).
Removed top 27 bits (of 52) from wire digital_to_analog_converter.padl_6.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padl_bits_7.
Removed top 1 bits (of 10) from wire digital_to_analog_converter.padr_0.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padr_8.
Removed top 1 bits (of 13) from wire digital_to_analog_converter.toSInt_imm_11.
Removed top 31 bits (of 32) from port B of cell sample_and_hold.$procmux$295_CMP0 ($eq).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:33$17 ($add).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_ideal_conv.sv:59$34 ($lt).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$ge$sar_adc_ideal_conv.sv:60$36 ($ge).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_ideal_conv.sv:65$44 ($gt).
Removed top 31 bits (of 32) from wire sar_tb_working.sys_counter.

2.10. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 78 unused wires.
<suppressed ~4 debug messages>

2.11. Executing MEMORY_COLLECT pass (generating $mem cells).

2.12. Executing OPT pass (performing simple optimizations).

2.12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_adc__N_BITS_10.
Optimizing module sar_tb_working.

2.12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_adc__N_BITS_10'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.12.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_adc__N_BITS_10..
Finding unused cells or wires in module \sar_tb_working..

2.12.4. Finished fast OPT passes.

2.13. Printing statistics.

=== $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000 ===

   Number of wires:                 15
   Number of wire bits:            139
   Number of public wires:           7
   Number of public wire bits:      38
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 10
     $add                            1
     $dff                            2
     $eq                             1
     $logic_not                      1
     $mux                            4
     $ne                             1

=== $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010 ===

   Number of wires:                 14
   Number of wire bits:             59
   Number of public wires:          11
   Number of public wire bits:      56
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $dff                            1
     $gt                             1
     $mux                            2
     $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010      1
     comparator_latch                1
     digital_to_analog_converter      1
     sample_and_hold                 1

=== $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010 ===

   Number of wires:                 36
   Number of wire bits:            285
   Number of public wires:           8
   Number of public wire bits:      30
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 41
     $add                            1
     $and                            1
     $dff                            2
     $div                            1
     $eq                            10
     $logic_not                      2
     $logic_or                       1
     $mux                           14
     $ne                             1
     $neg                            1
     $not                            1
     $or                             1
     $shift                          2
     $sub                            3

=== comparator_latch ===

   Number of wires:                425
   Number of wire bits:          17017
   Number of public wires:         384
   Number of public wire bits:   16258
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 65
     $add                           11
     $and                            5
     $dff                            4
     $div                            2
     $eq                             4
     $gt                             4
     $le                             2
     $logic_not                      1
     $mul                           14
     $mux                           10
     $neg                            1
     $not                            2
     $pmux                           3
     $reduce_or                      1
     $sub                            1

=== digital_to_analog_converter ===

   Number of wires:                 36
   Number of wire bits:            696
   Number of public wires:          36
   Number of public wire bits:     696
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $mul                            2

=== sample_and_hold ===

   Number of wires:                 16
   Number of wire bits:            216
   Number of public wires:           8
   Number of public wire bits:      66
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 10
     $dff                            2
     $eq                             1
     $logic_not                      1
     $mux                            5
     $pmux                           1

=== sar_adc__N_BITS_10 ===

   Number of wires:                  7
   Number of wire bits:             25
   Number of public wires:           7
   Number of public wire bits:      25
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010      1

=== sar_tb_working ===

   Number of wires:                 38
   Number of wire bits:            172
   Number of public wires:           9
   Number of public wire bits:      72
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 40
     $add                            1
     $assert                         1
     $assume                         9
     $dff                            9
     $ge                             1
     $gt                             1
     $initstate                      1
     $logic_not                      4
     $lt                             1
     $not                            1
     $or                             8
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000      1
     $reduce_bool                    1
     sar_adc__N_BITS_10              1

=== design hierarchy ===

   sar_tb_working                    1
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000      1
     sar_adc__N_BITS_10              1
       $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010      1
         $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010      1
         comparator_latch            1
         digital_to_analog_converter      1
         sample_and_hold             1

   Number of wires:                587
   Number of wire bits:          18609
   Number of public wires:         470
   Number of public wire bits:   17241
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                170
     $add                           14
     $and                            6
     $assert                         1
     $assume                         9
     $dff                           20
     $div                            3
     $eq                            16
     $ge                             1
     $gt                             6
     $initstate                      1
     $le                             2
     $logic_not                      9
     $logic_or                       1
     $lt                             1
     $mul                           16
     $mux                           35
     $ne                             2
     $neg                            2
     $not                            4
     $or                             9
     $pmux                           4
     $reduce_bool                    1
     $reduce_or                      1
     $shift                          2
     $sub                            4

2.14. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000...
Warning: Wire $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000.\sys_counter is used but has no driver.
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_adc__N_BITS_10...
Checking module sar_tb_working...
Warning: Wire sar_tb_working.$ne$sar_adc_ideal_conv.sv:63$41_Y is used but has no driver.
Found and reported 2 problems.

3. Executing HIERARCHY pass (managing design hierarchy).

3.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000

3.2. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     \sar_adc__N_BITS_10
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000001010
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000001010
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000001111101000
Removed 0 unused modules.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.

4. Executing jny backend.

5. Executing RTLIL backend.
Output filename: ../model/design.il

Warnings: 7 unique messages, 9 total
End of script. Logfile hash: 8b6e5826ef, CPU: user 0.34s system 0.01s, MEM: 21.31 MB peak
Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 29% 5x opt_clean (0 sec), 15% 2x check (0 sec), ...
