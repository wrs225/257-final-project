
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Executing script file `../model/design.ys' --

1. Executing Verilog-2005 frontend: sar_adc_ideal_conv.sv
Parsing formal SystemVerilog input from `sar_adc_ideal_conv.sv' to AST representation.
Storing AST representation for module `$abstract\comparator_latch'.
Storing AST representation for module `$abstract\digital_to_analog_converter'.
Storing AST representation for module `$abstract\sample_and_hold'.
Storing AST representation for module `$abstract\successive_approximation_register'.
Storing AST representation for module `$abstract\sar_adc'.
Storing AST representation for module `$abstract\sar_adc__N_BITS_10'.
Storing AST representation for module `$abstract\sar_tb_working'.
Storing AST representation for module `$abstract\frequency_divider'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_tb_working'.
Generating RTLIL representation for module `\sar_tb_working'.

2.2.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Parameter \DIVISION = 2

2.2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\frequency_divider'.
Parameter \DIVISION = 2
Generating RTLIL representation for module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Parameter \N_BITS = 1

2.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc__N_BITS_10'.
Parameter \N_BITS = 1
Generating RTLIL representation for module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001'.

2.2.4. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001
Parameter \N_BITS = 1

2.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\sar_adc'.
Parameter \N_BITS = 1
Generating RTLIL representation for module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001'.

2.2.6. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001

2.2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\comparator_latch'.
Generating RTLIL representation for module `\comparator_latch'.

2.2.8. Executing AST frontend in derive mode using pre-parsed AST for module `\digital_to_analog_converter'.
Generating RTLIL representation for module `\digital_to_analog_converter'.
Parameter \N_BITS = 1

2.2.9. Executing AST frontend in derive mode using pre-parsed AST for module `\successive_approximation_register'.
Parameter \N_BITS = 1
Generating RTLIL representation for module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001'.

2.2.10. Executing AST frontend in derive mode using pre-parsed AST for module `\sample_and_hold'.
Generating RTLIL representation for module `\sample_and_hold'.

2.2.11. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001
Used module:             \sample_and_hold

2.2.12. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001
Used module:             \comparator_latch
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001
Used module:             \sample_and_hold
Removing unused module `$abstract\frequency_divider'.
Removing unused module `$abstract\sar_tb_working'.
Removing unused module `$abstract\sar_adc__N_BITS_10'.
Removing unused module `$abstract\sar_adc'.
Removing unused module `$abstract\successive_approximation_register'.
Removing unused module `$abstract\sample_and_hold'.
Removing unused module `$abstract\digital_to_analog_converter'.
Removing unused module `$abstract\comparator_latch'.
Removed 8 unused modules.
Module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010 directly or indirectly contains formal properties -> setting "keep" attribute.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.
Warning: Resizing cell port $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.comparator_instance.out from 10 bits to 1 bits.
Warning: Resizing cell port $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.SAR_instance.quantized_voltage from 10 bits to 1 bits.

2.3. Executing PROC pass (convert processes to netlists).

2.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

2.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 3 switch rules as full_case in process $proc$./sample_and_hold.v:26$232 in module sample_and_hold.
Marked 1 switch rules as full_case in process $proc$./successive_approximation_register.v:31$196 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Marked 2 switch rules as full_case in process $proc$./successive_approximation_register.v:22$192 in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Marked 1 switch rules as full_case in process $proc$./comparator_latch.v:37$180 in module comparator_latch.
Marked 1 switch rules as full_case in process $proc$sar_adc_ideal_conv.sv:144$164 in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Marked 1 switch rules as full_case in process $proc$sar_adc_ideal_conv.sv:94$61 in module sar_tb_working.
Removed a total of 0 dead cases.

2.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 2 redundant assignments.
Promoted 57 assignments to connections.

2.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$160'.
  Set init value: $formal$sar_adc_ideal_conv.sv:121$29_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$158'.
  Set init value: $formal$sar_adc_ideal_conv.sv:115$28_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$156'.
  Set init value: $formal$sar_adc_ideal_conv.sv:114$27_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$154'.
  Set init value: $formal$sar_adc_ideal_conv.sv:113$26_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$152'.
  Set init value: $formal$sar_adc_ideal_conv.sv:103$25_EN = 1'0
Found init rule in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$150'.
  Set init value: $formal$sar_adc_ideal_conv.sv:101$24_EN = 1'0

2.3.5. Executing PROC_ARST pass (detect async resets in processes).

2.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~19 debug messages>

2.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:26$232'.
     1/2: $0\fsm[31:0]
     2/2: $0\state_cap[9:0]
Creating decoders for process `\sample_and_hold.$proc$./sample_and_hold.v:20$231'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:39$220'.
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
     1/4: $1$lookahead\quantized_voltage_register$195[0:0]$206
     2/4: $1$bitselwrite$sel$./successive_approximation_register.v:35$191[31:0]$205
     3/4: $1$bitselwrite$data$./successive_approximation_register.v:35$190[0:0]$204
     4/4: $1$bitselwrite$mask$./successive_approximation_register.v:35$189[0:0]$203
Creating decoders for process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:22$192'.
     1/1: $0\counter[0:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:37$180'.
     1/1: $0\fsm[31:0]
Creating decoders for process `\comparator_latch.$proc$./comparator_latch.v:31$179'.
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$173'.
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:152$168'.
     1/1: $0\output_clk_digital[0:0]
Creating decoders for process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:144$164'.
     1/1: $0\counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$160'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$158'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$156'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$154'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$152'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$150'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:120$97'.
     1/1: $0\held_value[9:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
     1/1: $0\hit_eoc[0:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
     1/1: $0\eoc_high_counter[31:0]
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:43$32'.
Creating decoders for process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:38$30'.

2.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.\quantized_voltage' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:39$220'.
No latch inferred for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$unnamed_block$2.i' from process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:39$220'.
No latch inferred for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$formal$sar_adc_ideal_conv.sv:140$162_CHECK' from process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$173'.
No latch inferred for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$formal$sar_adc_ideal_conv.sv:140$162_EN' from process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$173'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:57$3_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:57$3_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:59$5_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:59$5_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:60$7_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:60$7_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:62$9_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:62$9_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:64$11_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:64$11_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:66$13_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:66$13_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:67$15_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:67$15_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:68$17_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:68$17_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:76$19_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:76$19_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:77$20_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:77$20_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:77$21_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:77$21_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:80$22_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:80$22_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:81$23_CHECK' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
No latch inferred for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:81$23_EN' from process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.

2.3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\sample_and_hold.\state_cap' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$232'.
  created $dff cell `$procdff$298' with positive edge clock.
Creating register for signal `\sample_and_hold.\fsm' using process `\sample_and_hold.$proc$./sample_and_hold.v:26$232'.
  created $dff cell `$procdff$299' with positive edge clock.
Creating register for signal `\sample_and_hold.\prev_sys_clk' using process `\sample_and_hold.$proc$./sample_and_hold.v:20$231'.
  created $dff cell `$procdff$300' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.\quantized_voltage_register' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
  created $dff cell `$procdff$301' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$bitselwrite$mask$./successive_approximation_register.v:35$189' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
  created $dff cell `$procdff$302' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$bitselwrite$data$./successive_approximation_register.v:35$190' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
  created $dff cell `$procdff$303' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$bitselwrite$sel$./successive_approximation_register.v:35$191' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
  created $dff cell `$procdff$304' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$lookahead\quantized_voltage_register$195' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
  created $dff cell `$procdff$305' with positive edge clock.
Creating register for signal `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.\counter' using process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:22$192'.
  created $dff cell `$procdff$306' with positive edge clock.
Creating register for signal `\comparator_latch.\fsm' using process `\comparator_latch.$proc$./comparator_latch.v:37$180'.
  created $dff cell `$procdff$307' with positive edge clock.
Creating register for signal `\comparator_latch.\prev_sys_clk' using process `\comparator_latch.$proc$./comparator_latch.v:31$179'.
  created $dff cell `$procdff$308' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.\output_clk_digital' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:152$168'.
  created $dff cell `$procdff$309' with positive edge clock.
Creating register for signal `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.\counter' using process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:144$164'.
  created $dff cell `$procdff$310' with positive edge clock.
Creating register for signal `\sar_tb_working.\held_value' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:120$97'.
  created $dff cell `$procdff$311' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:121$29_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:120$97'.
  created $dff cell `$procdff$312' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:121$29_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:120$97'.
  created $dff cell `$procdff$313' with positive edge clock.
Creating register for signal `\sar_tb_working.\hit_eoc' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$314' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:113$26_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$315' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:113$26_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$316' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:114$27_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$317' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:114$27_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$318' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:115$28_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$319' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:115$28_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
  created $dff cell `$procdff$320' with positive edge clock.
Creating register for signal `\sar_tb_working.\eoc_high_counter' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
  created $dff cell `$procdff$321' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:101$24_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
  created $dff cell `$procdff$322' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:101$24_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
  created $dff cell `$procdff$323' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:103$25_CHECK' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
  created $dff cell `$procdff$324' with positive edge clock.
Creating register for signal `\sar_tb_working.$formal$sar_adc_ideal_conv.sv:103$25_EN' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
  created $dff cell `$procdff$325' with positive edge clock.
Creating register for signal `\sar_tb_working.\sys_counter' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:43$32'.
  created $dff cell `$procdff$326' with positive edge clock.
Creating register for signal `\sar_tb_working.\cycles' using process `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:38$30'.
  created $dff cell `$procdff$327' with positive edge clock.

2.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 6 empty switches in `\sample_and_hold.$proc$./sample_and_hold.v:26$232'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:26$232'.
Removing empty process `sample_and_hold.$proc$./sample_and_hold.v:20$231'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:39$220'.
Found and cleaned up 1 empty switch in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:31$196'.
Found and cleaned up 3 empty switches in `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:22$192'.
Removing empty process `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$proc$./successive_approximation_register.v:22$192'.
Found and cleaned up 4 empty switches in `\comparator_latch.$proc$./comparator_latch.v:37$180'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:37$180'.
Removing empty process `comparator_latch.$proc$./comparator_latch.v:31$179'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:0$173'.
Found and cleaned up 1 empty switch in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:152$168'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:152$168'.
Found and cleaned up 1 empty switch in `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:144$164'.
Removing empty process `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$proc$sar_adc_ideal_conv.sv:144$164'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$160'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$158'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$156'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$154'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$152'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$150'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:0$122'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:120$97'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:120$97'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:113$78'.
Found and cleaned up 1 empty switch in `\sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:94$61'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:73$34'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:43$32'.
Removing empty process `sar_tb_working.$proc$sar_adc_ideal_conv.sv:38$30'.
Cleaned up 19 empty switches.

2.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
<suppressed ~3 debug messages>
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
<suppressed ~5 debug messages>
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
<suppressed ~2 debug messages>
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
<suppressed ~1 debug messages>
Optimizing module sar_tb_working.
<suppressed ~14 debug messages>

2.4. Executing FUTURE pass.

2.5. Executing OPT_EXPR pass (perform const folding).
Optimizing module sample_and_hold.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Optimizing module digital_to_analog_converter.
Optimizing module comparator_latch.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module sar_tb_working.

2.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module \sar_tb_working..
Removed 12 unused cells and 144 unused wires.
<suppressed ~23 debug messages>

2.7. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010...
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001...
Checking module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_tb_working...
Found and reported 0 problems.

2.8. Executing OPT pass (performing simple optimizations).

2.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001'.
<suppressed ~15 debug messages>
Finding identical cells in module `\comparator_latch'.
<suppressed ~3 debug messages>
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
<suppressed ~6 debug messages>
Finding identical cells in module `\sar_tb_working'.
<suppressed ~51 debug messages>
Removed a total of 26 cells.

2.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$245.
    dead port 1/2 on $mux $procmux$250.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port B of cell $procmux$293: \hit_eoc -> 1'1
  Analyzing evaluation results.
Removed 2 multiplexer ports.
<suppressed ~12 debug messages>

2.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
  Optimizing cells in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
    New ctrl vector for $pmux cell $procmux$247: $procmux$240_CMP
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_tb_working.
  Optimizing cells in module \sar_tb_working.
Performed a total of 2 changes.

2.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 29 unused wires.
<suppressed ~5 debug messages>

2.8.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.8.8. Rerunning OPT passes. (Maybe there is more to do..)

2.8.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparator_latch..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \digital_to_analog_converter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \sample_and_hold..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \sar_tb_working..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

2.8.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
  Optimizing cells in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
  Optimizing cells in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
  Optimizing cells in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
  Optimizing cells in module \comparator_latch.
  Optimizing cells in module \digital_to_analog_converter.
  Optimizing cells in module \sample_and_hold.
  Optimizing cells in module \sar_tb_working.
Performed a total of 0 changes.

2.8.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.8.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..

2.8.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.8.14. Finished OPT passes. (There is nothing left to do.)

2.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$mul$sar_adc_ideal_conv.sv:146$165 ($mul).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$ne$sar_adc_ideal_conv.sv:146$166 ($ne).
Removed top 31 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$add$sar_adc_ideal_conv.sv:147$167 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.$eq$sar_adc_ideal_conv.sv:153$170 ($eq).
Removed top 9 bits (of 10) from wire $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.output_result_digital_prescale.
Removed top 30 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$div$./successive_approximation_register.v:35$207 ($div).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$add$./successive_approximation_register.v:26$194 ($add).
Removed top 31 bits (of 32) from port Y of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$add$./successive_approximation_register.v:26$194 ($add).
Removed top 31 bits (of 32) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$sub$./successive_approximation_register.v:35$208 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$sub$./successive_approximation_register.v:35$209 ($sub).
Removed top 31 bits (of 32) from port B of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$sub$./successive_approximation_register.v:0$210 ($sub).
Converting cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$sub$./successive_approximation_register.v:0$210 ($sub) from signed to unsigned.
Removed top 1 bits (of 33) from port A of cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$sub$./successive_approximation_register.v:0$210 ($sub).
Removed top 31 bits (of 32) from mux cell $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$ternary$./successive_approximation_register.v:42$227 ($mux).
Removed top 31 bits (of 32) from wire $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.$add$./successive_approximation_register.v:26$194_Y.
Removed top 9 bits (of 10) from port B of cell comparator_latch.$gt$./comparator_latch.v:43$181 ($gt).
Removed top 31 bits (of 32) from port B of cell comparator_latch.$procmux$279_CMP0 ($eq).
Removed top 29 bits (of 42) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$187 ($mul).
Removed top 21 bits (of 42) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$187 ($mul).
Removed top 8 bits (of 42) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:52$187 ($mul).
Removed top 27 bits (of 52) from port A of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$188 ($mul).
Removed top 48 bits (of 52) from port B of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$188 ($mul).
Removed top 24 bits (of 52) from port Y of cell digital_to_analog_converter.$mul$./digital_to_analog_converter.v:68$188 ($mul).
Removed top 27 bits (of 52) from wire digital_to_analog_converter.padl_6.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padl_bits_7.
Removed top 1 bits (of 10) from wire digital_to_analog_converter.padr_0.
Removed top 1 bits (of 26) from wire digital_to_analog_converter.padr_8.
Removed top 1 bits (of 13) from wire digital_to_analog_converter.toSInt_imm_11.
Removed top 31 bits (of 32) from port B of cell sample_and_hold.$procmux$237_CMP0 ($eq).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$div$sar_adc_ideal_conv.sv:111$77 ($div).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:39$31 ($add).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:44$33 ($add).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_ideal_conv.sv:76$46 ($lt).
Removed top 30 bits (of 32) from port B of cell sar_tb_working.$ge$sar_adc_ideal_conv.sv:77$48 ($ge).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_ideal_conv.sv:80$50 ($gt).
Removed top 25 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_ideal_conv.sv:83$58 ($gt).
Removed top 23 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_ideal_conv.sv:83$59 ($lt).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:95$69 ($add).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$eq$sar_adc_ideal_conv.sv:101$70 ($eq).
Removed top 21 bits (of 32) from port A of cell sar_tb_working.$mul$sar_adc_ideal_conv.sv:111$76 ($mul).
Removed top 11 bits (of 32) from port Y of cell sar_tb_working.$mul$sar_adc_ideal_conv.sv:111$76 ($mul).
Removed top 22 bits (of 32) from port B of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:114$85 ($add).
Removed top 11 bits (of 32) from port Y of cell sar_tb_working.$add$sar_adc_ideal_conv.sv:114$85 ($add).
Removed top 11 bits (of 32) from port B of cell sar_tb_working.$lt$sar_adc_ideal_conv.sv:114$86 ($lt).
Removed top 22 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_ideal_conv.sv:115$87 ($gt).
Removed top 22 bits (of 32) from port B of cell sar_tb_working.$sub$sar_adc_ideal_conv.sv:115$89 ($sub).
Removed top 11 bits (of 32) from port Y of cell sar_tb_working.$sub$sar_adc_ideal_conv.sv:115$89 ($sub).
Removed top 22 bits (of 32) from port B of cell sar_tb_working.$le$sar_adc_ideal_conv.sv:116$92 ($le).
Removed top 31 bits (of 32) from port B of cell sar_tb_working.$gt$sar_adc_ideal_conv.sv:116$94 ($gt).
Removed top 59 bits (of 64) from port B of cell sar_tb_working.$eq$sar_adc_ideal_conv.sv:121$100 ($eq).
Removed top 11 bits (of 32) from wire sar_tb_working.$add$sar_adc_ideal_conv.sv:114$85_Y.
Removed top 11 bits (of 32) from wire sar_tb_working.$mul$sar_adc_ideal_conv.sv:111$76_Y.

2.10. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..
Removed 0 unused cells and 10 unused wires.
<suppressed ~4 debug messages>

2.11. Executing MEMORY_COLLECT pass (generating $mem cells).

2.12. Executing OPT pass (performing simple optimizations).

2.12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010.
Optimizing module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001.
Optimizing module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001.
Optimizing module comparator_latch.
Optimizing module digital_to_analog_converter.
Optimizing module sample_and_hold.
Optimizing module sar_tb_working.

2.12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010'.
Finding identical cells in module `$paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `$paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001'.
Finding identical cells in module `\comparator_latch'.
Finding identical cells in module `\digital_to_analog_converter'.
Finding identical cells in module `\sample_and_hold'.
Finding identical cells in module `\sar_tb_working'.
Removed a total of 0 cells.

2.12.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010..
Finding unused cells or wires in module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001..
Finding unused cells or wires in module \comparator_latch..
Finding unused cells or wires in module \digital_to_analog_converter..
Finding unused cells or wires in module \sample_and_hold..
Finding unused cells or wires in module \sar_tb_working..

2.12.4. Finished fast OPT passes.

2.13. Printing statistics.

=== $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010 ===

   Number of wires:                 14
   Number of wire bits:            138
   Number of public wires:           5
   Number of public wire bits:      36
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 12
     $add                            1
     $assume                         1
     $dff                            2
     $eq                             1
     $initstate                      1
     $logic_not                      2
     $mul                            1
     $mux                            2
     $ne                             1

=== $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001 ===

   Number of wires:                 13
   Number of wire bits:             67
   Number of public wires:          13
   Number of public wire bits:      67
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  4
     $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001      1
     comparator_latch                1
     digital_to_analog_converter      1
     sample_and_hold                 1

=== $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001 ===

   Number of wires:                  7
   Number of wire bits:             25
   Number of public wires:           7
   Number of public wire bits:      25
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001      1

=== $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001 ===

   Number of wires:                 27
   Number of wire bits:            184
   Number of public wires:           8
   Number of public wire bits:       8
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 23
     $add                            1
     $and                            1
     $dff                            2
     $div                            1
     $logic_and                      1
     $logic_not                      3
     $logic_or                       1
     $mux                            5
     $neg                            1
     $not                            1
     $or                             1
     $shift                          2
     $sub                            3

=== comparator_latch ===

   Number of wires:                 24
   Number of wire bits:            262
   Number of public wires:          12
   Number of public wire bits:     126
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 14
     $and                            2
     $dff                            1
     $eq                             1
     $gt                             2
     $le                             2
     $logic_not                      1
     $mux                            4
     $pmux                           1

=== digital_to_analog_converter ===

   Number of wires:                 36
   Number of wire bits:            696
   Number of public wires:          36
   Number of public wire bits:     696
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $mul                            2

=== sample_and_hold ===

   Number of wires:                 16
   Number of wire bits:            216
   Number of public wires:           8
   Number of public wire bits:      66
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 10
     $dff                            2
     $eq                             1
     $logic_not                      1
     $mux                            5
     $pmux                           1

=== sar_tb_working ===

   Number of wires:                 75
   Number of wire bits:            524
   Number of public wires:          13
   Number of public wire bits:     184
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 88
     $add                            4
     $and                            4
     $assert                         6
     $assume                        13
     $dff                           14
     $div                            1
     $eq                             2
     $ge                             1
     $gt                             5
     $initstate                      1
     $le                             1
     $logic_not                     12
     $logic_or                       1
     $lt                             3
     $mul                            1
     $mux                            2
     $not                            2
     $or                            11
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010      1
     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001      1
     $reduce_bool                    1
     $sub                            1

=== design hierarchy ===

   sar_tb_working                    1
     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010      1
     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001      1
       $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001      1
         $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001      1
         comparator_latch            1
         digital_to_analog_converter      1
         sample_and_hold             1

   Number of wires:                212
   Number of wire bits:           2112
   Number of public wires:         102
   Number of public wire bits:    1208
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                147
     $add                            6
     $and                            7
     $assert                         6
     $assume                        14
     $dff                           21
     $div                            2
     $eq                             5
     $ge                             1
     $gt                             7
     $initstate                      2
     $le                             3
     $logic_and                      1
     $logic_not                     19
     $logic_or                       2
     $lt                             3
     $mul                            4
     $mux                           18
     $ne                             1
     $neg                            1
     $not                            3
     $or                            12
     $pmux                           2
     $reduce_bool                    1
     $shift                          2
     $sub                            4

2.14. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010...
Checking module $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001...
Checking module $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001...
Checking module $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001...
Checking module comparator_latch...
Checking module digital_to_analog_converter...
Checking module sample_and_hold...
Checking module sar_tb_working...
Found and reported 0 problems.

3. Executing HIERARCHY pass (managing design hierarchy).

3.1. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010

3.2. Analyzing design hierarchy..
Top module:  \sar_tb_working
Used module:     $paramod\sar_adc__N_BITS_10\N_BITS=s32'00000000000000000000000000000001
Used module:         $paramod\sar_adc\N_BITS=s32'00000000000000000000000000000001
Used module:             \digital_to_analog_converter
Used module:             $paramod\successive_approximation_register\N_BITS=s32'00000000000000000000000000000001
Used module:             \comparator_latch
Used module:             \sample_and_hold
Used module:     $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010
Removed 0 unused modules.
Module $paramod\frequency_divider\DIVISION=s32'00000000000000000000000000000010 directly or indirectly contains formal properties -> setting "keep" attribute.
Module sar_tb_working directly or indirectly contains formal properties -> setting "keep" attribute.

4. Executing jny backend.

5. Executing RTLIL backend.
Output filename: ../model/design.il

Warnings: 2 unique messages, 2 total
End of script. Logfile hash: ba61d300b1, CPU: user 0.20s system 0.01s, MEM: 13.88 MB peak
Yosys 0.34+14 (git sha1 11b9deba9, clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 19% 6x opt_expr (0 sec), 18% 5x opt_clean (0 sec), ...
