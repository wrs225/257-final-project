//-------------------------------------------------------------------------
// sar_adc__N_BITS_10.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder sar_adc Definition
// At /home/will/Desktop/AchourLab/AnalogBenChmark/benchmarks/sar_adc_ideal/sar_adc.py

//***********************************************************
// Pickled source file of placeholder sar_adc__N_BITS_10
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder sar_adc
//-----------------------------------------------------------

`ifndef SAR_ADC
`define SAR_ADC

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component sar_adc__N_BITS_10.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component sar_adc__N_BITS_10

`line 1 "sar_adc.v" 0
`line 1 "./comparator.v" 0


module comparator
(
  input clk,
  input reset,
  input sys_clk,
  input [10-1:0] p_voltage_real,
  input [10-1:0] n_voltage_real,
  output [1-1:0] out_digital
);

  reg [4-1:0] state_cycle_counter;
  reg [1-1:0] prev_sys_clk;
  reg [32-1:0] fsm;
  localparam fsm_init = 0;
  wire [13-1:0] truncR_0;
  wire [13-1:0] const_1;
  assign const_1 = 13'd4096;
  assign truncR_0 = const_1;
  wire [14-1:0] truncR_2;
  wire [15-1:0] toUsInt_3;
  wire [15-1:0] const_4;
  assign const_4 = 15'd0;
  assign toUsInt_3 = const_4;
  assign truncR_2 = toUsInt_3[11:0];
  assign out_digital = (fsm == 0)? truncR_0[12:12] : truncR_2[13:13];

  always @(posedge clk) begin
    prev_sys_clk <= sys_clk;
  end

  localparam fsm_1 = 1;

  always @(posedge clk) begin
    if(reset) begin
      fsm <= fsm_init;
    end else begin
      case(fsm)
        fsm_init: begin
          if((p_voltage_real > 10'd0) & (p_voltage_real <= n_voltage_real)) begin
            fsm <= fsm_1;
          end 
        end
        fsm_1: begin
          if((p_voltage_real > n_voltage_real) & (p_voltage_real <= 10'd512)) begin
            fsm <= fsm_init;
          end 
        end
      endcase
    end
  end


endmodule


`line 2 "sar_adc.v" 0
`line 1 "./digital_to_analog_converter.v" 0


module digital_to_analog_converter
(
  input clk,
  input reset,
  input [10-1:0] input_voltage_digital,
  output [10-1:0] output_voltage_real
);

  wire [10-1:0] padr_0;
  wire [1-1:0] padr_bits_1;
  assign padr_bits_1 = 0;
  wire [9-1:0] padl_2;
  wire [8-1:0] padl_bits_3;
  wire [28-1:0] truncR_4;
  wire [52-1:0] truncval_5;
  wire [52-1:0] padl_6;
  wire [26-1:0] padl_bits_7;
  wire [26-1:0] padr_8;
  wire [13-1:0] padr_bits_9;
  assign padr_bits_9 = 0;
  wire [1-1:0] toSInt_10;
  assign toSInt_10 = 0;
  wire [13-1:0] toSInt_imm_11;
  wire [34-1:0] truncR_12;
  wire [42-1:0] truncval_13;
  wire [42-1:0] padl_14;
  wire [21-1:0] padl_bits_15;
  wire [21-1:0] padl_16;
  wire [13-1:0] padl_bits_17;
  wire [13-1:0] const_18;
  assign const_18 = 13'd6758;
  assign padl_bits_17 = const_18;
  wire [8-1:0] padl_bits_zero_19;
  assign padl_bits_zero_19 = 0;
  assign padl_16 = { padl_bits_zero_19, padl_bits_17 };
  assign padl_bits_15 = padl_16;
  wire [21-1:0] padl_bits_zero_20;
  assign padl_bits_zero_20 = 0;
  assign padl_14 = { padl_bits_zero_20, padl_bits_15 };
  wire [42-1:0] padl_21;
  wire [21-1:0] padl_bits_22;
  wire [21-1:0] padr_23;
  wire [11-1:0] padr_bits_24;
  assign padr_bits_24 = 0;
  assign padr_23 = { input_voltage_digital, padr_bits_24 };
  assign padl_bits_22 = padr_23;
  wire [21-1:0] padl_bits_zero_25;
  assign padl_bits_zero_25 = 0;
  assign padl_21 = { padl_bits_zero_25, padl_bits_22 };
  assign truncval_13 = padl_14 * padl_21;
  assign truncR_12 = truncval_13[33:0];
  assign toSInt_imm_11 = { toSInt_10, truncR_12[33:22] };
  assign padr_8 = { toSInt_imm_11, padr_bits_9 };
  assign padl_bits_7 = padr_8;
  assign padl_6 = { { 26{ padl_bits_7[25] } }, padl_bits_7 };
  wire [52-1:0] padl_26;
  wire [26-1:0] padl_bits_27;
  wire [26-1:0] padl_28;
  wire [15-1:0] padl_bits_29;
  wire [15-1:0] const_30;
  assign const_30 = 15'd8;
  assign padl_bits_29 = const_30;
  assign padl_28 = { { 11{ padl_bits_29[14] } }, padl_bits_29 };
  assign padl_bits_27 = padl_28;
  assign padl_26 = { { 26{ padl_bits_27[25] } }, padl_bits_27 };
  assign truncval_5 = padl_6 * padl_26;
  assign truncR_4 = truncval_5[27:0];
  assign padl_bits_3 = truncR_4[27:20];
  wire [1-1:0] padl_bits_zero_31;
  assign padl_bits_zero_31 = 0;
  assign padl_2 = { padl_bits_zero_31, padl_bits_3 };
  assign padr_0 = { padl_2, padr_bits_1 };
  assign output_voltage_real = padr_0;

endmodule


`line 3 "sar_adc.v" 0
`line 1 "./sample_and_hold.v" 0


module sample_and_hold
(
  input clk,
  input reset,
  input sys_clk,
  input [10-1:0] input_voltage_real,
  output [10-1:0] output_voltage_real,
  input [1-1:0] input_control_digital
);

  reg [4-1:0] state_cycle_counter;
  reg [1-1:0] prev_sys_clk;
  reg [10-1:0] state_cap;
  reg [32-1:0] fsm;
  localparam fsm_init = 0;
  assign output_voltage_real = state_cap;

  always @(posedge clk) begin
    prev_sys_clk <= sys_clk;
  end

  localparam fsm_1 = 1;

  always @(posedge clk) begin
    if(reset) begin
      fsm <= fsm_init;
    end else begin
      case(fsm)
        fsm_init: begin
          if(reset) begin
            state_cap <= 10'd0;
          end else begin
            state_cap <= input_voltage_real;
          end
          if(input_control_digital) begin
            fsm <= fsm_1;
          end 
        end
        fsm_1: begin
          if(reset) begin
            state_cap <= 10'd0;
          end else begin
            state_cap <= state_cap;
          end
          if(!input_control_digital) begin
            fsm <= fsm_init;
          end 
        end
      endcase
    end
  end


endmodule


`line 4 "sar_adc.v" 0
`line 1 "./successive_approximation_register.v" 0

module successive_approximation_register #(
    parameter N_BITS = 10
)
(
    input  logic feedback_value,
    input  logic conduct_comparison,

    output logic [N_BITS - 1:0] quantized_voltage,
    output logic               eoc,

    input logic clk,
    input logic reset
);

logic [$clog2(N_BITS) - 1:0] counter;

//need to double buffer the output becaues tecnically the SAR outputs a 1
// for the bit under comparison
logic[N_BITS - 1:0] quantized_voltage_register;

always@(posedge clk) begin
    if(reset) begin
        counter <= 0;
    end else if(conduct_comparison) begin
        if(counter != N_BITS - 1) counter <= counter + 1;
        else counter <= 0;
    end
end

always@(posedge clk) begin
    if(reset || !conduct_comparison) begin
        quantized_voltage_register <= 0;
    end else begin 
        quantized_voltage_register[N_BITS - counter - 1] <= feedback_value;
    end
end

always@(*) begin
    int i;
    for(i=0;i<N_BITS;i++) begin
        quantized_voltage[i] = (N_BITS - counter - 1 == i) ? 1:quantized_voltage_register[i];
    end
end

assign eoc = (counter == N_BITS - 1);


endmodule
`line 5 "sar_adc.v" 0


module sar_adc 
#(
    parameter N_BITS = 10 
)
(

    input logic [9:0] input_voltage_real,
    
    input logic input_hold_digital,

    output logic eoc,
    output logic [N_BITS - 1:0] output_result_digital,


    input logic clk,
    input logic sys_clk,
    input logic reset
);

logic [9:0] p_voltage_real;
logic [9:0] n_voltage_real;

logic       comparator_output_digital;

sample_and_hold sah
(
  .clk(clk),
  .reset(reset),
  .sys_clk(sys_clk),
  .input_voltage_real(input_voltage_real),
  .output_voltage_real(p_voltage_real),
  .input_control_digital(input_hold_digital)
);

successive_approximation_register #(
    .N_BITS(N_BITS)
) SAR_instance (
    .feedback_value(comparator_output_digital), 
    .quantized_voltage(output_result_digital),
    .conduct_comparison(input_hold_digital),
    .eoc(eoc), 
    .clk(sys_clk), 
    .reset(reset) 
);


digital_to_analog_converter DAC_instance (
    .clk(clk), 
    .reset(reset), 
    .input_voltage_digital(output_result_digital), 
    .output_voltage_real(n_voltage_real) 
);

comparator comparator_instance (
    .clk(clk),              
    .reset(reset),            
    .sys_clk(sys_clk),          
    .p_voltage_real(p_voltage_real),   
    .n_voltage_real(n_voltage_real),   
    .out_digital(comparator_output_digital)       
);


endmodule
`endif /* SAR_ADC */
//-----------------------------------------------------------
// Wrapper of placeholder sar_adc__N_BITS_10
//-----------------------------------------------------------

`ifndef SAR_ADC__N_BITS_10
`define SAR_ADC__N_BITS_10

module sar_adc__N_BITS_10
(
  input logic [1-1:0] clk ,
  output logic [1-1:0] eoc ,
  input logic [1-1:0] input_hold_digital ,
  input logic [10-1:0] input_voltage_real ,
  output logic [10-1:0] output_result_digital ,
  input logic [1-1:0] reset ,
  input logic [1-1:0] sys_clk 
);
  sar_adc
  #(
    .N_BITS( 10 )
  ) v
  (
    .clk( clk ),
    .eoc( eoc ),
    .input_hold_digital( input_hold_digital ),
    .input_voltage_real( input_voltage_real ),
    .output_result_digital( output_result_digital ),
    .reset( reset ),
    .sys_clk( sys_clk )
  );
endmodule

`endif /* SAR_ADC__N_BITS_10 */

