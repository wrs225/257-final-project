//-------------------------------------------------------------------------
// sar_adc__NBITS_10.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder sar_adc Definition
// At /home/will/Desktop/AchourLab/AnalogBenChmark/benchmarks/sar_adc/sar_adc.py

//***********************************************************
// Pickled source file of placeholder sar_adc__NBITS_10
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder sar_adc
//-----------------------------------------------------------

`ifndef SAR_ADC
`define SAR_ADC

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component sar_adc__NBITS_10.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component sar_adc__NBITS_10

`line 1 "sar_adc.v" 0
`line 1 "./comparator.v" 0


module comparator
(
  input clk,
  input reset,
  input sys_clk,
  input [10-1:0] p_voltage_real,
  input [10-1:0] n_voltage_real,
  output [1-1:0] out_digital
);

  reg [4-1:0] state_cycle_counter;
  reg [1-1:0] prev_sys_clk;
  reg [32-1:0] fsm;
  localparam fsm_init = 0;
  wire [13-1:0] truncR_0;
  wire [13-1:0] const_1;
  assign const_1 = 13'd4096;
  assign truncR_0 = const_1;
  assign out_digital = truncR_0[12:12];
  wire [14-1:0] truncR_2;
  wire [15-1:0] toUsInt_3;
  wire [15-1:0] const_4;
  assign const_4 = 15'd0;
  assign toUsInt_3 = const_4;
  assign truncR_2 = toUsInt_3[11:0];

  always @(posedge clk) begin
    prev_sys_clk <= sys_clk;
  end

  localparam fsm_1 = 1;

  always @(posedge clk) begin
    if(reset) begin
      fsm <= fsm_init;
    end else begin
      case(fsm)
        fsm_init: begin
          if((p_voltage_real > -10'sd512) & (p_voltage_real <= n_voltage_real)) begin
            fsm <= fsm_1;
          end 
        end
        fsm_1: begin
          if((p_voltage_real > n_voltage_real) & (p_voltage_real <= 10'd512)) begin
            fsm <= fsm_init;
          end 
        end
      endcase
    end
  end


endmodule


`line 2 "sar_adc.v" 0
`line 1 "./digital_to_analog_converter.v" 0


module digital_to_analog_converter
(
  input clk,
  input reset,
  input [11-1:0] input_voltage_digital,
  output [10-1:0] output_voltage_real
);

  wire [10-1:0] padr_0;
  wire [7-1:0] padr_bits_1;
  assign padr_bits_1 = 0;
  wire [11-1:0] truncval_2;
  assign truncval_2 = input_voltage_digital;
  assign padr_0 = { truncval_2[2:0], padr_bits_1 };
  assign output_voltage_real = padr_0;

endmodule


`line 3 "sar_adc.v" 0
`line 1 "./sample_and_hold.v" 0


module sample_and_hold
(
  input clk,
  input reset,
  input sys_clk,
  input [10-1:0] input_voltage_real,
  output [10-1:0] output_voltage_real,
  input [1-1:0] input_control_digital
);

  reg [4-1:0] state_cycle_counter;
  reg [1-1:0] prev_sys_clk;
  reg [10-1:0] state_cap;
  reg [32-1:0] fsm;
  localparam fsm_init = 0;
  assign output_voltage_real = state_cap;

  always @(posedge clk) begin
    prev_sys_clk <= sys_clk;
  end

  localparam fsm_1 = 1;

  always @(posedge clk) begin
    if(reset) begin
      fsm <= fsm_init;
    end else begin
      case(fsm)
        fsm_init: begin
          if(reset) begin
            state_cap <= 10'd0;
          end else begin
            state_cap <= input_voltage_real;
          end
          if(input_control_digital) begin
            fsm <= fsm_1;
          end 
        end
        fsm_1: begin
          if(reset) begin
            state_cap <= 10'd0;
          end else begin
            state_cap <= state_cap;
          end
          if(!input_control_digital) begin
            fsm <= fsm_init;
          end 
        end
      endcase
    end
  end


endmodule


`line 4 "sar_adc.v" 0
`line 1 "./successive_approximation_register.v" 0

module successive_approximation_register #(
    parameter N_BITS = 10
)
(
    input  logic feedback_value,
    input  logic conduct_comparison,

    output logic [N_BITS - 1:0] quantized_voltage,
    output logic               eoc,

    input logic clk,
    input logic reset
);

logic [$clog2(N_BITS) - 1:0] counter;

always@(posedge clk) begin
    if(reset) begin
        counter <= 0;
    end else if(conduct_comparison) begin
        if(counter != N_BITS) counter <= counter + 1;
        else counter <= 0;
    end
end

always@(posedge clk) begin
    if(reset) begin
        quantized_voltage <= 0;
    end else begin 
        quantized_voltage[counter] <= feedback_value;
    end
end

assign eoc = (counter == N_BITS);


endmodule
`line 5 "sar_adc.v" 0


module sar_adc 
#(
    parameter N_BITS = 10 
)
(

    input logic [9:0] input_voltage_real,
    
    input logic input_hold_digital,

    output logic eoc,
    output logic [N_BITS - 1:0] output_result_digital,


    input logic clk,
    input logic reset
);

logic [9:0] p_voltage_real;
logic [9:0] n_voltage_real;

logic       comparator_output_digital;

sample_and_hold sah
(
  .clk(clk),
  .reset(reset),
  .sys_clk(clk),
  .input_voltage_real(input_voltage_real),
  .output_voltage_real(p_voltage_real),
  .input_control_digital(input_hold_digital)
);

successive_approximation_register #(
    .N_BITS(N_BITS)
) SAR_instance (
    .feedback_value(comparator_output_digital), 
    .quantized_voltage(output_result_digital),
    .conduct_comparison(!input_hold_digital),
    .eoc(eoc), 
    .clk(clk), 
    .reset(reset) 
);


digital_to_analog_converter DAC_instance (
    .clk(clk), 
    .reset(reset), 
    .input_voltage_digital(input_hold_digital), 
    .output_voltage_real(n_voltage_real) 
);

comparator comparator_instance (
    .clk(clk),              
    .reset(reset),            
    .sys_clk(clk),          
    .p_voltage_real(p_voltage_real),   
    .n_voltage_real(n_voltage_real),   
    .out_digital(comparator_output_digital)       
);


endmodule
`endif /* SAR_ADC */
//-----------------------------------------------------------
// Wrapper of placeholder sar_adc__NBITS_10
//-----------------------------------------------------------

`ifndef SAR_ADC__NBITS_10
`define SAR_ADC__NBITS_10

module sar_adc__NBITS_10
(
  input logic [1-1:0] clk ,
  output logic [1-1:0] eoc ,
  input logic [1-1:0] input_hold_digital ,
  input logic [10-1:0] input_voltage_real ,
  input logic [10-1:0] output_result_digital ,
  input logic [1-1:0] reset 
);
  sar_adc
  #(
    .NBITS( 10 )
  ) v
  (
    .clk( clk ),
    .eoc( eoc ),
    .input_hold_digital( input_hold_digital ),
    .input_voltage_real( input_voltage_real ),
    .output_result_digital( output_result_digital ),
    .reset( reset )
  );
endmodule

`endif /* SAR_ADC__NBITS_10 */

